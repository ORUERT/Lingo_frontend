{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, watch, computed, watchEffect } from 'vue';\nimport { qrProps } from './interface';\nimport qrcodegen from './qrcodegen';\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen.QrCode.Ecc.LOW,\n  M: qrcodegen.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen.QrCode.Ecc.QUARTILE,\n  H: qrcodegen.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = 'L';\nvar DEFAULT_BGCOLOR = '#FFFFFF';\nvar DEFAULT_FGCOLOR = '#000000';\nvar DEFAULT_INCLUDEMARGIN = false;\nvar SPEC_MARGIN_SIZE = 4;\nvar DEFAULT_MARGIN_SIZE = 0;\n// This is *very* rough estimate of max amount of QRCode allowed to be covered.\n// It is \"wrong\" in a lot of ways (area is a terrible way to estimate, it\n// really should be number of modules covered), but if for some reason we don't\n// get an explicit height or width, I'd rather default to something than throw.\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules) {\n  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ops = [];\n  modules.forEach(function (row, y) {\n    var start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        // M0 0h7v1H0z injects the space with the move and drops the comma,\n        // saving a char per operation\n        ops.push(\"M\".concat(start + margin, \" \").concat(y + margin, \"h\").concat(x - start, \"v1H\").concat(start + margin, \"z\"));\n        start = null;\n        return;\n      }\n      // end of row, clean up or skip\n      if (x === row.length - 1) {\n        if (!cell) {\n          // We would have closed the op above already so this can only mean\n          // 2+ light modules in a row.\n          return;\n        }\n        if (start === null) {\n          // Just a single dark module.\n          ops.push(\"M\".concat(x + margin, \",\").concat(y + margin, \" h1v1H\").concat(x + margin, \"z\"));\n        } else {\n          // Otherwise finish the current line.\n          ops.push(\"M\".concat(start + margin, \",\").concat(y + margin, \" h\").concat(x + 1 - start, \"v1H\").concat(start + margin, \"z\"));\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n}\n// We could just do this in generatePath, except that we want to support\n// non-Path2D canvas, so we need to keep it an explicit step.\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map(function (row, y) {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map(function (cell, x) {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  var numCells = cells.length + margin * 2;\n  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  var scale = numCells / size;\n  var w = (imageSettings.width || defaultSize) * scale;\n  var h = (imageSettings.height || defaultSize) * scale;\n  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  var excavation = null;\n  if (imageSettings.excavate) {\n    var floorX = Math.floor(x);\n    var floorY = Math.floor(y);\n    var ceilW = Math.ceil(w + x - floorX);\n    var ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n  return {\n    x: x,\n    y: y,\n    h: h,\n    w: w,\n    excavation: excavation\n  };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.floor(marginSize);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n// For canvas we're going to switch our drawing mode based on whether or not\n// the environment supports Path2D. We only need the constructor to be\n// supported, but Edge doesn't actually support the path (string) type\n// argument. Luckily it also doesn't support the addPath() method. We can\n// treat that as the same thing.\nvar SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nexport var QRCodeCanvas = defineComponent({\n  name: 'QRCodeCanvas',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number\n  }),\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      expose = _ref.expose;\n    var imgSrc = computed(function () {\n      var _a;\n      return (_a = props.imageSettings) === null || _a === void 0 ? void 0 : _a.src;\n    });\n    var _canvas = shallowRef(null);\n    var _image = shallowRef(null);\n    var isImgLoaded = shallowRef(false);\n    expose({\n      toDataURL: function toDataURL(type, quality) {\n        var _a;\n        return (_a = _canvas.value) === null || _a === void 0 ? void 0 : _a.toDataURL(type, quality);\n      }\n    });\n    watchEffect(function () {\n      var value = props.value,\n        _props$size = props.size,\n        size = _props$size === void 0 ? DEFAULT_SIZE : _props$size,\n        _props$level = props.level,\n        level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level,\n        _props$bgColor = props.bgColor,\n        bgColor = _props$bgColor === void 0 ? DEFAULT_BGCOLOR : _props$bgColor,\n        _props$fgColor = props.fgColor,\n        fgColor = _props$fgColor === void 0 ? DEFAULT_FGCOLOR : _props$fgColor,\n        _props$includeMargin = props.includeMargin,\n        includeMargin = _props$includeMargin === void 0 ? DEFAULT_INCLUDEMARGIN : _props$includeMargin,\n        marginSize = props.marginSize,\n        imageSettings = props.imageSettings;\n      if (_canvas.value != null) {\n        var canvas = _canvas.value;\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n          return;\n        }\n        var cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n        var margin = getMarginSize(includeMargin, marginSize);\n        var numCells = cells.length + margin * 2;\n        var calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n        var image = _image.value;\n        var haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n          }\n        }\n        // We're going to scale this so that the number of drawable units\n        // matches the number of cells. This avoids rounding issues, but does\n        // result in some potentially unwanted single pixel issues between\n        // blocks, only in environments that don't support Path2D.\n        var pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        var scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        // Draw solid background, only paint dark modules.\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          // $FlowFixMe: Path2D c'tor doesn't support args yet.\n          ctx.fill(new Path2D(generatePath(cells, margin)));\n        } else {\n          cells.forEach(function (row, rdx) {\n            row.forEach(function (cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n        }\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(imgSrc, function () {\n      isImgLoaded.value = false;\n    });\n    return function () {\n      var _a;\n      var size = (_a = props.size) !== null && _a !== void 0 ? _a : DEFAULT_SIZE;\n      var canvasStyle = {\n        height: \"\".concat(size, \"px\"),\n        width: \"\".concat(size, \"px\")\n      };\n      var img = null;\n      if (imgSrc.value != null) {\n        img = _createVNode(\"img\", {\n          \"src\": imgSrc.value,\n          \"key\": imgSrc.value,\n          \"style\": {\n            display: 'none'\n          },\n          \"onLoad\": function onLoad() {\n            isImgLoaded.value = true;\n          },\n          \"ref\": _image\n        }, null);\n      }\n      return _createVNode(_Fragment, null, [_createVNode(\"canvas\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"style\": [canvasStyle, attrs.style],\n        \"ref\": _canvas\n      }), null), img]);\n    };\n  }\n});\nexport var QRCodeSVG = defineComponent({\n  name: 'QRCodeSVG',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    color: String,\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number,\n    title: String\n  }),\n  setup: function setup(props) {\n    var cells = null;\n    var margin = null;\n    var numCells = null;\n    var calculatedImageSettings = null;\n    var fgPath = null;\n    var image = null;\n    watchEffect(function () {\n      var value = props.value,\n        _props$size2 = props.size,\n        size = _props$size2 === void 0 ? DEFAULT_SIZE : _props$size2,\n        _props$level2 = props.level,\n        level = _props$level2 === void 0 ? DEFAULT_LEVEL : _props$level2,\n        _props$includeMargin2 = props.includeMargin,\n        includeMargin = _props$includeMargin2 === void 0 ? DEFAULT_INCLUDEMARGIN : _props$includeMargin2,\n        marginSize = props.marginSize,\n        imageSettings = props.imageSettings;\n      cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n      margin = getMarginSize(includeMargin, marginSize);\n      numCells = cells.length + margin * 2;\n      calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n      if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n          cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = _createVNode(\"image\", {\n          \"xlink:href\": imageSettings.src,\n          \"height\": calculatedImageSettings.h,\n          \"width\": calculatedImageSettings.w,\n          \"x\": calculatedImageSettings.x + margin,\n          \"y\": calculatedImageSettings.y + margin,\n          \"preserveAspectRatio\": \"none\"\n        }, null);\n      }\n      // Drawing strategy: instead of a rect per module, we're going to create a\n      // single path for the dark modules and layer that on top of a light rect,\n      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's\n      // way faster than DOM ops.\n      // For level 1, 441 nodes -> 2\n      // For level 40, 31329 -> 2\n      fgPath = generatePath(cells, margin);\n    });\n    return function () {\n      var bgColor = props.bgColor && DEFAULT_BGCOLOR;\n      var fgColor = props.fgColor && DEFAULT_FGCOLOR;\n      return _createVNode(\"svg\", {\n        \"height\": props.size,\n        \"width\": props.size,\n        \"viewBox\": \"0 0 \".concat(numCells, \" \").concat(numCells)\n      }, [!!props.title && _createVNode(\"title\", null, [props.title]), _createVNode(\"path\", {\n        \"fill\": bgColor,\n        \"d\": \"M0,0 h\".concat(numCells, \"v\").concat(numCells, \"H0z\"),\n        \"shape-rendering\": \"crispEdges\"\n      }, null), _createVNode(\"path\", {\n        \"fill\": fgColor,\n        \"d\": fgPath,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), image]);\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","Fragment","_Fragment","createVNode","_createVNode","defineComponent","shallowRef","watch","computed","watchEffect","qrProps","qrcodegen","ERROR_LEVEL_MAP","L","QrCode","Ecc","LOW","M","MEDIUM","Q","QUARTILE","H","HIGH","DEFAULT_SIZE","DEFAULT_LEVEL","DEFAULT_BGCOLOR","DEFAULT_FGCOLOR","DEFAULT_INCLUDEMARGIN","SPEC_MARGIN_SIZE","DEFAULT_MARGIN_SIZE","DEFAULT_IMG_SCALE","generatePath","modules","margin","arguments","length","undefined","ops","forEach","row","y","start","cell","x","push","concat","join","excavateModules","excavation","slice","map","h","w","getImageSettings","cells","size","imageSettings","numCells","defaultSize","Math","floor","scale","width","height","excavate","floorX","floorY","ceilW","ceil","ceilH","getMarginSize","includeMargin","marginSize","SUPPORTS_PATH2D","Path2D","addPath","e","QRCodeCanvas","name","inheritAttrs","props","level","String","bgColor","fgColor","Number","setup","_ref","attrs","expose","imgSrc","_a","src","_canvas","_image","isImgLoaded","toDataURL","type","quality","value","_props$size","_props$level","_props$bgColor","_props$fgColor","_props$includeMargin","canvas","ctx","getContext","encodeText","getModules","calculatedImageSettings","image","haveImageToRender","complete","naturalHeight","naturalWidth","pixelRatio","window","devicePixelRatio","fillStyle","fillRect","fill","rdx","cdx","drawImage","flush","canvasStyle","img","display","onLoad","style","QRCodeSVG","color","title","fgPath","_props$size2","_props$level2","_props$includeMargin2"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/qrcode/QRCode.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, watch, computed, watchEffect } from 'vue';\nimport { qrProps } from './interface';\nimport qrcodegen from './qrcodegen';\nconst ERROR_LEVEL_MAP = {\n  L: qrcodegen.QrCode.Ecc.LOW,\n  M: qrcodegen.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen.QrCode.Ecc.QUARTILE,\n  H: qrcodegen.QrCode.Ecc.HIGH\n};\nconst DEFAULT_SIZE = 128;\nconst DEFAULT_LEVEL = 'L';\nconst DEFAULT_BGCOLOR = '#FFFFFF';\nconst DEFAULT_FGCOLOR = '#000000';\nconst DEFAULT_INCLUDEMARGIN = false;\nconst SPEC_MARGIN_SIZE = 4;\nconst DEFAULT_MARGIN_SIZE = 0;\n// This is *very* rough estimate of max amount of QRCode allowed to be covered.\n// It is \"wrong\" in a lot of ways (area is a terrible way to estimate, it\n// really should be number of modules covered), but if for some reason we don't\n// get an explicit height or width, I'd rather default to something than throw.\nconst DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules) {\n  let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ops = [];\n  modules.forEach(function (row, y) {\n    let start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        // M0 0h7v1H0z injects the space with the move and drops the comma,\n        // saving a char per operation\n        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);\n        start = null;\n        return;\n      }\n      // end of row, clean up or skip\n      if (x === row.length - 1) {\n        if (!cell) {\n          // We would have closed the op above already so this can only mean\n          // 2+ light modules in a row.\n          return;\n        }\n        if (start === null) {\n          // Just a single dark module.\n          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n        } else {\n          // Otherwise finish the current line.\n          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n}\n// We could just do this in generatePath, except that we want to support\n// non-Path2D canvas, so we need to keep it an explicit step.\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map((row, y) => {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map((cell, x) => {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  const numCells = cells.length + margin * 2;\n  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  const scale = numCells / size;\n  const w = (imageSettings.width || defaultSize) * scale;\n  const h = (imageSettings.height || defaultSize) * scale;\n  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  let excavation = null;\n  if (imageSettings.excavate) {\n    const floorX = Math.floor(x);\n    const floorY = Math.floor(y);\n    const ceilW = Math.ceil(w + x - floorX);\n    const ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n  return {\n    x,\n    y,\n    h,\n    w,\n    excavation\n  };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.floor(marginSize);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n// For canvas we're going to switch our drawing mode based on whether or not\n// the environment supports Path2D. We only need the constructor to be\n// supported, but Edge doesn't actually support the path (string) type\n// argument. Luckily it also doesn't support the addPath() method. We can\n// treat that as the same thing.\nconst SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nexport const QRCodeCanvas = defineComponent({\n  name: 'QRCodeCanvas',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number\n  }),\n  setup(props, _ref) {\n    let {\n      attrs,\n      expose\n    } = _ref;\n    const imgSrc = computed(() => {\n      var _a;\n      return (_a = props.imageSettings) === null || _a === void 0 ? void 0 : _a.src;\n    });\n    const _canvas = shallowRef(null);\n    const _image = shallowRef(null);\n    const isImgLoaded = shallowRef(false);\n    expose({\n      toDataURL: (type, quality) => {\n        var _a;\n        return (_a = _canvas.value) === null || _a === void 0 ? void 0 : _a.toDataURL(type, quality);\n      }\n    });\n    watchEffect(() => {\n      const {\n        value,\n        size = DEFAULT_SIZE,\n        level = DEFAULT_LEVEL,\n        bgColor = DEFAULT_BGCOLOR,\n        fgColor = DEFAULT_FGCOLOR,\n        includeMargin = DEFAULT_INCLUDEMARGIN,\n        marginSize,\n        imageSettings\n      } = props;\n      if (_canvas.value != null) {\n        const canvas = _canvas.value;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n          return;\n        }\n        let cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n        const margin = getMarginSize(includeMargin, marginSize);\n        const numCells = cells.length + margin * 2;\n        const calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n        const image = _image.value;\n        const haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n          }\n        }\n        // We're going to scale this so that the number of drawable units\n        // matches the number of cells. This avoids rounding issues, but does\n        // result in some potentially unwanted single pixel issues between\n        // blocks, only in environments that don't support Path2D.\n        const pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        const scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        // Draw solid background, only paint dark modules.\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          // $FlowFixMe: Path2D c'tor doesn't support args yet.\n          ctx.fill(new Path2D(generatePath(cells, margin)));\n        } else {\n          cells.forEach(function (row, rdx) {\n            row.forEach(function (cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n        }\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(imgSrc, () => {\n      isImgLoaded.value = false;\n    });\n    return () => {\n      var _a;\n      const size = (_a = props.size) !== null && _a !== void 0 ? _a : DEFAULT_SIZE;\n      const canvasStyle = {\n        height: `${size}px`,\n        width: `${size}px`\n      };\n      let img = null;\n      if (imgSrc.value != null) {\n        img = _createVNode(\"img\", {\n          \"src\": imgSrc.value,\n          \"key\": imgSrc.value,\n          \"style\": {\n            display: 'none'\n          },\n          \"onLoad\": () => {\n            isImgLoaded.value = true;\n          },\n          \"ref\": _image\n        }, null);\n      }\n      return _createVNode(_Fragment, null, [_createVNode(\"canvas\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"style\": [canvasStyle, attrs.style],\n        \"ref\": _canvas\n      }), null), img]);\n    };\n  }\n});\nexport const QRCodeSVG = defineComponent({\n  name: 'QRCodeSVG',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    color: String,\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number,\n    title: String\n  }),\n  setup(props) {\n    let cells = null;\n    let margin = null;\n    let numCells = null;\n    let calculatedImageSettings = null;\n    let fgPath = null;\n    let image = null;\n    watchEffect(() => {\n      const {\n        value,\n        size = DEFAULT_SIZE,\n        level = DEFAULT_LEVEL,\n        includeMargin = DEFAULT_INCLUDEMARGIN,\n        marginSize,\n        imageSettings\n      } = props;\n      cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n      margin = getMarginSize(includeMargin, marginSize);\n      numCells = cells.length + margin * 2;\n      calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n      if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n          cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = _createVNode(\"image\", {\n          \"xlink:href\": imageSettings.src,\n          \"height\": calculatedImageSettings.h,\n          \"width\": calculatedImageSettings.w,\n          \"x\": calculatedImageSettings.x + margin,\n          \"y\": calculatedImageSettings.y + margin,\n          \"preserveAspectRatio\": \"none\"\n        }, null);\n      }\n      // Drawing strategy: instead of a rect per module, we're going to create a\n      // single path for the dark modules and layer that on top of a light rect,\n      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's\n      // way faster than DOM ops.\n      // For level 1, 441 nodes -> 2\n      // For level 40, 31329 -> 2\n      fgPath = generatePath(cells, margin);\n    });\n    return () => {\n      const bgColor = props.bgColor && DEFAULT_BGCOLOR;\n      const fgColor = props.fgColor && DEFAULT_FGCOLOR;\n      return _createVNode(\"svg\", {\n        \"height\": props.size,\n        \"width\": props.size,\n        \"viewBox\": `0 0 ${numCells} ${numCells}`\n      }, [!!props.title && _createVNode(\"title\", null, [props.title]), _createVNode(\"path\", {\n        \"fill\": bgColor,\n        \"d\": `M0,0 h${numCells}v${numCells}H0z`,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), _createVNode(\"path\", {\n        \"fill\": fgColor,\n        \"d\": fgPath,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), image]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}