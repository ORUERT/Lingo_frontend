{"ast":null,"code":"import _toConsumableArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport { computed, ref, watchEffect } from 'vue';\nimport { useBaseProps } from '../../vc-select';\nimport KeyCode from '../../_util/KeyCode';\nimport { SEARCH_MARK } from '../hooks/useSearchOptions';\nexport default (function (context, options, fieldNames, activeValueCells, setActiveValueCells,\n// containerRef: Ref<HTMLElement>,\nonKeyBoardSelect) {\n  var baseProps = useBaseProps();\n  var rtl = computed(function () {\n    return baseProps.direction === 'rtl';\n  });\n  var _ref = [ref([]), ref(), ref([])],\n    validActiveValueCells = _ref[0],\n    lastActiveIndex = _ref[1],\n    lastActiveOptions = _ref[2];\n  watchEffect(function () {\n    var activeIndex = -1;\n    var currentOptions = options.value;\n    var mergedActiveIndexes = [];\n    var mergedActiveValueCells = [];\n    var len = activeValueCells.value.length;\n    // Fill validate active value cells and index\n    var _loop = function _loop(i) {\n      // Mark the active index for current options\n      var nextActiveIndex = currentOptions.findIndex(function (option) {\n        return option[fieldNames.value.value] === activeValueCells.value[i];\n      });\n      if (nextActiveIndex === -1) {\n        return 1; // break\n      }\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells.value[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.value.children];\n    };\n    for (var i = 0; i < len && currentOptions; i += 1) {\n      if (_loop(i)) break;\n    }\n    // Fill last active options\n    var activeOptions = options.value;\n    for (var _i = 0; _i < mergedActiveIndexes.length - 1; _i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[_i]][fieldNames.value.children];\n    }\n    var _ref2 = [mergedActiveValueCells, activeIndex, activeOptions];\n    validActiveValueCells.value = _ref2[0];\n    lastActiveIndex.value = _ref2[1];\n    lastActiveOptions.value = _ref2[2];\n  });\n  // Update active value cells and scroll to target element\n  var internalSetActiveValueCells = function internalSetActiveValueCells(next) {\n    setActiveValueCells(next);\n  };\n  // Same options offset\n  var offsetActiveOption = function offsetActiveOption(offset) {\n    var len = lastActiveOptions.value.length;\n    var currentIndex = lastActiveIndex.value;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (var i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      var option = lastActiveOptions.value[currentIndex];\n      if (option && !option.disabled) {\n        var value = option[fieldNames.value.value];\n        var nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n  // Different options offset\n  var prevColumn = function prevColumn() {\n    if (validActiveValueCells.value.length > 1) {\n      var nextActiveCells = validActiveValueCells.value.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      baseProps.toggleOpen(false);\n    }\n  };\n  var nextColumn = function nextColumn() {\n    var _a;\n    var nextOptions = ((_a = lastActiveOptions.value[lastActiveIndex.value]) === null || _a === void 0 ? void 0 : _a[fieldNames.value.children]) || [];\n    var nextOption = nextOptions.find(function (option) {\n      return !option.disabled;\n    });\n    if (nextOption) {\n      var nextActiveCells = [].concat(_toConsumableArray(validActiveValueCells.value), [nextOption[fieldNames.value.value]]);\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  context.expose({\n    // scrollTo: treeRef.current?.scrollTo,\n    onKeydown: function onKeydown(event) {\n      var which = event.which;\n      switch (which) {\n        // >>> Arrow keys\n        case KeyCode.UP:\n        case KeyCode.DOWN:\n          {\n            var offset = 0;\n            if (which === KeyCode.UP) {\n              offset = -1;\n            } else if (which === KeyCode.DOWN) {\n              offset = 1;\n            }\n            if (offset !== 0) {\n              offsetActiveOption(offset);\n            }\n            break;\n          }\n        case KeyCode.LEFT:\n          {\n            if (rtl.value) {\n              nextColumn();\n            } else {\n              prevColumn();\n            }\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            if (rtl.value) {\n              prevColumn();\n            } else {\n              nextColumn();\n            }\n            break;\n          }\n        case KeyCode.BACKSPACE:\n          {\n            if (!baseProps.searchValue) {\n              prevColumn();\n            }\n            break;\n          }\n        // >>> Select\n        case KeyCode.ENTER:\n          {\n            if (validActiveValueCells.value.length) {\n              var option = lastActiveOptions.value[lastActiveIndex.value];\n              // Search option should revert back of origin options\n              var originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];\n              if (originOptions.length) {\n                onKeyBoardSelect(originOptions.map(function (opt) {\n                  return opt[fieldNames.value.value];\n                }), originOptions[originOptions.length - 1]);\n              } else {\n                onKeyBoardSelect(validActiveValueCells.value, option);\n              }\n            }\n            break;\n          }\n        // >>> Close\n        case KeyCode.ESC:\n          {\n            baseProps.toggleOpen(false);\n            if (open) {\n              event.stopPropagation();\n            }\n          }\n      }\n    },\n    onKeyup: function onKeyup() {}\n  });\n});","map":{"version":3,"names":["computed","ref","watchEffect","useBaseProps","KeyCode","SEARCH_MARK","context","options","fieldNames","activeValueCells","setActiveValueCells","onKeyBoardSelect","baseProps","rtl","direction","_ref","validActiveValueCells","lastActiveIndex","lastActiveOptions","activeIndex","currentOptions","value","mergedActiveIndexes","mergedActiveValueCells","len","length","_loop","i","nextActiveIndex","findIndex","option","push","children","activeOptions","_ref2","internalSetActiveValueCells","next","offsetActiveOption","offset","currentIndex","disabled","nextActiveCells","slice","concat","prevColumn","toggleOpen","nextColumn","_a","nextOptions","nextOption","find","_toConsumableArray","expose","onKeydown","event","which","UP","DOWN","LEFT","RIGHT","BACKSPACE","searchValue","ENTER","originOptions","map","opt","ESC","open","stopPropagation","onKeyup"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/vc-cascader/OptionList/useKeyboard.js"],"sourcesContent":["import { computed, ref, watchEffect } from 'vue';\nimport { useBaseProps } from '../../vc-select';\nimport KeyCode from '../../_util/KeyCode';\nimport { SEARCH_MARK } from '../hooks/useSearchOptions';\nexport default ((context, options, fieldNames, activeValueCells, setActiveValueCells,\n// containerRef: Ref<HTMLElement>,\nonKeyBoardSelect) => {\n  const baseProps = useBaseProps();\n  const rtl = computed(() => baseProps.direction === 'rtl');\n  const [validActiveValueCells, lastActiveIndex, lastActiveOptions] = [ref([]), ref(), ref([])];\n  watchEffect(() => {\n    let activeIndex = -1;\n    let currentOptions = options.value;\n    const mergedActiveIndexes = [];\n    const mergedActiveValueCells = [];\n    const len = activeValueCells.value.length;\n    // Fill validate active value cells and index\n    for (let i = 0; i < len && currentOptions; i += 1) {\n      // Mark the active index for current options\n      const nextActiveIndex = currentOptions.findIndex(option => option[fieldNames.value.value] === activeValueCells.value[i]);\n      if (nextActiveIndex === -1) {\n        break;\n      }\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells.value[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.value.children];\n    }\n    // Fill last active options\n    let activeOptions = options.value;\n    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.value.children];\n    }\n    [validActiveValueCells.value, lastActiveIndex.value, lastActiveOptions.value] = [mergedActiveValueCells, activeIndex, activeOptions];\n  });\n  // Update active value cells and scroll to target element\n  const internalSetActiveValueCells = next => {\n    setActiveValueCells(next);\n  };\n  // Same options offset\n  const offsetActiveOption = offset => {\n    const len = lastActiveOptions.value.length;\n    let currentIndex = lastActiveIndex.value;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (let i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      const option = lastActiveOptions.value[currentIndex];\n      if (option && !option.disabled) {\n        const value = option[fieldNames.value.value];\n        const nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n  // Different options offset\n  const prevColumn = () => {\n    if (validActiveValueCells.value.length > 1) {\n      const nextActiveCells = validActiveValueCells.value.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      baseProps.toggleOpen(false);\n    }\n  };\n  const nextColumn = () => {\n    var _a;\n    const nextOptions = ((_a = lastActiveOptions.value[lastActiveIndex.value]) === null || _a === void 0 ? void 0 : _a[fieldNames.value.children]) || [];\n    const nextOption = nextOptions.find(option => !option.disabled);\n    if (nextOption) {\n      const nextActiveCells = [...validActiveValueCells.value, nextOption[fieldNames.value.value]];\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  context.expose({\n    // scrollTo: treeRef.current?.scrollTo,\n    onKeydown: event => {\n      const {\n        which\n      } = event;\n      switch (which) {\n        // >>> Arrow keys\n        case KeyCode.UP:\n        case KeyCode.DOWN:\n          {\n            let offset = 0;\n            if (which === KeyCode.UP) {\n              offset = -1;\n            } else if (which === KeyCode.DOWN) {\n              offset = 1;\n            }\n            if (offset !== 0) {\n              offsetActiveOption(offset);\n            }\n            break;\n          }\n        case KeyCode.LEFT:\n          {\n            if (rtl.value) {\n              nextColumn();\n            } else {\n              prevColumn();\n            }\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            if (rtl.value) {\n              prevColumn();\n            } else {\n              nextColumn();\n            }\n            break;\n          }\n        case KeyCode.BACKSPACE:\n          {\n            if (!baseProps.searchValue) {\n              prevColumn();\n            }\n            break;\n          }\n        // >>> Select\n        case KeyCode.ENTER:\n          {\n            if (validActiveValueCells.value.length) {\n              const option = lastActiveOptions.value[lastActiveIndex.value];\n              // Search option should revert back of origin options\n              const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];\n              if (originOptions.length) {\n                onKeyBoardSelect(originOptions.map(opt => opt[fieldNames.value.value]), originOptions[originOptions.length - 1]);\n              } else {\n                onKeyBoardSelect(validActiveValueCells.value, option);\n              }\n            }\n            break;\n          }\n        // >>> Close\n        case KeyCode.ESC:\n          {\n            baseProps.toggleOpen(false);\n            if (open) {\n              event.stopPropagation();\n            }\n          }\n      }\n    },\n    onKeyup: () => {}\n  });\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}