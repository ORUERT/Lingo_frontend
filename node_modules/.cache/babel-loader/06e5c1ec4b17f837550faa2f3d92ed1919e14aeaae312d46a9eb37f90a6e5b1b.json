{"ast":null,"code":"import _defineProperty from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.timers.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport omit from '../_util/omit';\nimport useStyle from './style';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      \"default\": getDefaultTarget\n    },\n    prefixCls: String,\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  inheritAttrs: false,\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose,\n      attrs = _ref.attrs;\n    var placeholderNode = shallowRef();\n    var fixedNode = shallowRef();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var placeholderRect = getTargetRect(placeholderNode.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      var targetRect = getTargetRect(targetNode);\n      var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        var width = \"\".concat(placeholderRect.width, \"px\");\n        var height = \"\".concat(placeholderRect.height, \"px\");\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: width,\n          height: height\n        };\n        newState.placeholderStyle = {\n          width: width,\n          height: height\n        };\n      } else if (fixedBottom !== undefined) {\n        var _width = \"\".concat(placeholderRect.width, \"px\");\n        var _height = \"\".concat(placeholderRect.height, \"px\");\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: _width,\n          height: _height\n        };\n        newState.placeholderStyle = {\n          width: _width,\n          height: _height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderRect = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    var _useStyle = useStyle(prefixCls),\n      _useStyle2 = _slicedToArray(_useStyle, 2),\n      wrapSSR = _useStyle2[0],\n      hashId = _useStyle2[1];\n    return function () {\n      var _classNames;\n      var _a;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames((_classNames = {}, _defineProperty(_classNames, prefixCls.value, affixStyle), _defineProperty(_classNames, hashId.value, true), _classNames));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return wrapSSR(_createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        \"default\": function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread(_objectSpread({}, restProps), attrs), {}, {\n            \"ref\": placeholderNode\n          }), [affixStyle && _createVNode(\"div\", {\n            \"style\": placeholderStyle,\n            \"aria-hidden\": \"true\"\n          }, null), _createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots[\"default\"]) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      }));\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","defineComponent","shallowRef","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","useStyle","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","prefixCls","String","onChange","onTestUpdatePosition","Affix","compatConfig","MODE","name","inheritAttrs","props","setup","_ref","slots","emit","expose","attrs","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","concat","position","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_useStyle","_useStyle2","_slicedToArray","wrapSSR","hashId","_classNames","_a","className","_defineProperty","restProps","_default","call"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport omit from '../_util/omit';\nimport useStyle from './style';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport const affixProps = () => ({\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: Number,\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: Number,\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: {\n    type: Function,\n    default: getDefaultTarget\n  },\n  prefixCls: String,\n  /** 固定状态改变时触发的回调函数 */\n  onChange: Function,\n  onTestUpdatePosition: Function\n});\nconst Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  inheritAttrs: false,\n  props: affixProps(),\n  setup(props, _ref) {\n    let {\n      slots,\n      emit,\n      expose,\n      attrs\n    } = _ref;\n    const placeholderNode = shallowRef();\n    const fixedNode = shallowRef();\n    const state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    const currentInstance = getCurrentInstance();\n    const offsetTop = computed(() => {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    const offsetBottom = computed(() => props.offsetBottom);\n    const measure = () => {\n      const {\n        status,\n        lastAffix\n      } = state;\n      const {\n        target\n      } = props;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      const targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      const newState = {\n        status: AffixStatus.None\n      };\n      const placeholderRect = getTargetRect(placeholderNode.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        const width = `${placeholderRect.width}px`;\n        const height = `${placeholderRect.height}px`;\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width,\n          height\n        };\n        newState.placeholderStyle = {\n          width,\n          height\n        };\n      } else if (fixedBottom !== undefined) {\n        const width = `${placeholderRect.width}px`;\n        const height = `${placeholderRect.height}px`;\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width,\n          height\n        };\n        newState.placeholderStyle = {\n          width,\n          height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    const prepareMeasure = () => {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    const updatePosition = throttleByAnimationFrame(() => {\n      prepareMeasure();\n    });\n    const lazyUpdatePosition = throttleByAnimationFrame(() => {\n      const {\n        target\n      } = props;\n      const {\n        affixStyle\n      } = state;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        const targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          const targetRect = getTargetRect(targetNode);\n          const placeholderRect = getTargetRect(placeholderNode.value);\n          const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition,\n      lazyUpdatePosition\n    });\n    watch(() => props.target, val => {\n      const newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(() => [props.offsetTop, props.offsetBottom], updatePosition);\n    onMounted(() => {\n      const {\n        target\n      } = props;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(() => {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(() => {\n      measure();\n    });\n    onUnmounted(() => {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    const {\n      prefixCls\n    } = useConfigInject('affix', props);\n    const [wrapSSR, hashId] = useStyle(prefixCls);\n    return () => {\n      var _a;\n      const {\n        affixStyle,\n        placeholderStyle\n      } = state;\n      const className = classNames({\n        [prefixCls.value]: affixStyle,\n        [hashId.value]: true\n      });\n      const restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return wrapSSR(_createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: () => [_createVNode(\"div\", _objectSpread(_objectSpread(_objectSpread({}, restProps), attrs), {}, {\n          \"ref\": placeholderNode\n        }), [affixStyle && _createVNode(\"div\", {\n          \"style\": placeholderStyle,\n          \"aria-hidden\": \"true\"\n        }, null), _createVNode(\"div\", {\n          \"class\": className,\n          \"ref\": fixedNode,\n          \"style\": affixStyle\n        }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])]\n      }));\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":";;;;AAAA,OAAOA,aAAa,MAAM,0CAA0C;AACpE,OAAOC,QAAQ,MAAM,oCAAoC;AACzD,SAASC,WAAW,IAAIC,YAAY,QAAQ,KAAK;AACjD,SAASC,eAAe,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,SAAS,EAAEC,kBAAkB,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,SAAS,QAAQ,KAAK;AACnI,OAAOC,UAAU,MAAM,qBAAqB;AAC5C,OAAOC,cAAc,MAAM,uBAAuB;AAClD,OAAOC,wBAAwB,MAAM,mCAAmC;AACxE,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,gBAAgB,EAAEC,mBAAmB,EAAEC,aAAa,EAAEC,WAAW,EAAEC,cAAc,QAAQ,SAAS;AAC3G,OAAOC,eAAe,MAAM,0CAA0C;AACtE,OAAOC,IAAI,MAAM,eAAe;AAChC,OAAOC,QAAQ,MAAM,SAAS;AAC9B,SAASC,gBAAgBA,CAAA,EAAG;EAC1B,OAAO,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,GAAG,IAAI;AACtD;AACA,IAAIC,WAAW;AACf,CAAC,UAAUA,WAAW,EAAE;EACtBA,WAAW,CAACA,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC7CA,WAAW,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;AACrD,CAAC,EAAEA,WAAW,KAAKA,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;AACrC;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAA;EAAA,OAAU;IAC/B;AACF;AACA;IACEC,SAAS,EAAEC,MAAM;IACjB;IACAC,YAAY,EAAED,MAAM;IACpB;IACAE,MAAM,EAAE;MACNC,IAAI,EAAEC,QAAQ;MACd,WAAST;IACX,CAAC;IACDU,SAAS,EAAEC,MAAM;IACjB;IACAC,QAAQ,EAAEH,QAAQ;IAClBI,oBAAoB,EAAEJ;EACxB,CAAC;AAAA,CAAC;AACF,IAAMK,KAAK,GAAGnC,eAAe,CAAC;EAC5BoC,YAAY,EAAE;IACZC,IAAI,EAAE;EACR,CAAC;EACDC,IAAI,EAAE,QAAQ;EACdC,YAAY,EAAE,KAAK;EACnBC,KAAK,EAAEhB,UAAU,CAAC,CAAC;EACnBiB,KAAK,WAAAA,MAACD,KAAK,EAAEE,IAAI,EAAE;IACjB,IACEC,KAAK,GAIHD,IAAI,CAJNC,KAAK;MACLC,IAAI,GAGFF,IAAI,CAHNE,IAAI;MACJC,MAAM,GAEJH,IAAI,CAFNG,MAAM;MACNC,KAAK,GACHJ,IAAI,CADNI,KAAK;IAEP,IAAMC,eAAe,GAAG9C,UAAU,CAAC,CAAC;IACpC,IAAM+C,SAAS,GAAG/C,UAAU,CAAC,CAAC;IAC9B,IAAMgD,KAAK,GAAG/C,QAAQ,CAAC;MACrBgD,UAAU,EAAEC,SAAS;MACrBC,gBAAgB,EAAED,SAAS;MAC3BE,MAAM,EAAE9B,WAAW,CAAC+B,IAAI;MACxBC,SAAS,EAAE,KAAK;MAChBC,UAAU,EAAE,IAAI;MAChBC,OAAO,EAAE;IACX,CAAC,CAAC;IACF,IAAMC,eAAe,GAAGrD,kBAAkB,CAAC,CAAC;IAC5C,IAAMoB,SAAS,GAAGnB,QAAQ,CAAC,YAAM;MAC/B,OAAOkC,KAAK,CAACb,YAAY,KAAKwB,SAAS,IAAIX,KAAK,CAACf,SAAS,KAAK0B,SAAS,GAAG,CAAC,GAAGX,KAAK,CAACf,SAAS;IAChG,CAAC,CAAC;IACF,IAAME,YAAY,GAAGrB,QAAQ,CAAC;MAAA,OAAMkC,KAAK,CAACb,YAAY;IAAA,EAAC;IACvD,IAAMgC,OAAO,GAAG,SAAVA,OAAOA,CAAA,EAAS;MACpB,IACEN,MAAM,GAEJJ,KAAK,CAFPI,MAAM;QACNE,SAAS,GACPN,KAAK,CADPM,SAAS;MAEX,IACE3B,MAAM,GACJY,KAAK,CADPZ,MAAM;MAER,IAAIyB,MAAM,KAAK9B,WAAW,CAACqC,OAAO,IAAI,CAACZ,SAAS,CAACa,KAAK,IAAI,CAACd,eAAe,CAACc,KAAK,IAAI,CAACjC,MAAM,EAAE;QAC3F;MACF;MACA,IAAMkC,UAAU,GAAGlC,MAAM,CAAC,CAAC;MAC3B,IAAI,CAACkC,UAAU,EAAE;QACf;MACF;MACA,IAAMC,QAAQ,GAAG;QACfV,MAAM,EAAE9B,WAAW,CAAC+B;MACtB,CAAC;MACD,IAAMU,eAAe,GAAGjD,aAAa,CAACgC,eAAe,CAACc,KAAK,CAAC;MAC5D,IAAIG,eAAe,CAACC,GAAG,KAAK,CAAC,IAAID,eAAe,CAACE,IAAI,KAAK,CAAC,IAAIF,eAAe,CAACG,KAAK,KAAK,CAAC,IAAIH,eAAe,CAACI,MAAM,KAAK,CAAC,EAAE;QAC1H;MACF;MACA,IAAMC,UAAU,GAAGtD,aAAa,CAAC+C,UAAU,CAAC;MAC5C,IAAMQ,QAAQ,GAAGtD,WAAW,CAACgD,eAAe,EAAEK,UAAU,EAAE5C,SAAS,CAACoC,KAAK,CAAC;MAC1E,IAAMU,WAAW,GAAGtD,cAAc,CAAC+C,eAAe,EAAEK,UAAU,EAAE1C,YAAY,CAACkC,KAAK,CAAC;MACnF,IAAIG,eAAe,CAACC,GAAG,KAAK,CAAC,IAAID,eAAe,CAACE,IAAI,KAAK,CAAC,IAAIF,eAAe,CAACG,KAAK,KAAK,CAAC,IAAIH,eAAe,CAACI,MAAM,KAAK,CAAC,EAAE;QAC1H;MACF;MACA,IAAIE,QAAQ,KAAKnB,SAAS,EAAE;QAC1B,IAAMgB,KAAK,MAAAK,MAAA,CAAMR,eAAe,CAACG,KAAK,OAAI;QAC1C,IAAMC,MAAM,MAAAI,MAAA,CAAMR,eAAe,CAACI,MAAM,OAAI;QAC5CL,QAAQ,CAACb,UAAU,GAAG;UACpBuB,QAAQ,EAAE,OAAO;UACjBR,GAAG,EAAEK,QAAQ;UACbH,KAAK,EAALA,KAAK;UACLC,MAAM,EAANA;QACF,CAAC;QACDL,QAAQ,CAACX,gBAAgB,GAAG;UAC1Be,KAAK,EAALA,KAAK;UACLC,MAAM,EAANA;QACF,CAAC;MACH,CAAC,MAAM,IAAIG,WAAW,KAAKpB,SAAS,EAAE;QACpC,IAAMgB,MAAK,MAAAK,MAAA,CAAMR,eAAe,CAACG,KAAK,OAAI;QAC1C,IAAMC,OAAM,MAAAI,MAAA,CAAMR,eAAe,CAACI,MAAM,OAAI;QAC5CL,QAAQ,CAACb,UAAU,GAAG;UACpBuB,QAAQ,EAAE,OAAO;UACjBC,MAAM,EAAEH,WAAW;UACnBJ,KAAK,EAALA,MAAK;UACLC,MAAM,EAANA;QACF,CAAC;QACDL,QAAQ,CAACX,gBAAgB,GAAG;UAC1Be,KAAK,EAALA,MAAK;UACLC,MAAM,EAANA;QACF,CAAC;MACH;MACAL,QAAQ,CAACR,SAAS,GAAG,CAAC,CAACQ,QAAQ,CAACb,UAAU;MAC1C,IAAIK,SAAS,KAAKQ,QAAQ,CAACR,SAAS,EAAE;QACpCX,IAAI,CAAC,QAAQ,EAAEmB,QAAQ,CAACR,SAAS,CAAC;MACpC;MACA;MACA1D,QAAQ,CAACoD,KAAK,EAAEc,QAAQ,CAAC;IAC3B,CAAC;IACD,IAAMY,cAAc,GAAG,SAAjBA,cAAcA,CAAA,EAAS;MAC3B9E,QAAQ,CAACoD,KAAK,EAAE;QACdI,MAAM,EAAE9B,WAAW,CAACqC,OAAO;QAC3BV,UAAU,EAAEC,SAAS;QACrBC,gBAAgB,EAAED;MACpB,CAAC,CAAC;MACFO,eAAe,CAACkB,MAAM,CAAC,CAAC;MACxB;MACA,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EAAE;QACnCnC,IAAI,CAAC,oBAAoB,CAAC;MAC5B;IACF,CAAC;IACD,IAAMoC,cAAc,GAAGrE,wBAAwB,CAAC,YAAM;MACpDgE,cAAc,CAAC,CAAC;IAClB,CAAC,CAAC;IACF,IAAMM,kBAAkB,GAAGtE,wBAAwB,CAAC,YAAM;MACxD,IACEiB,MAAM,GACJY,KAAK,CADPZ,MAAM;MAER,IACEsB,UAAU,GACRD,KAAK,CADPC,UAAU;MAEZ;MACA,IAAItB,MAAM,IAAIsB,UAAU,EAAE;QACxB,IAAMY,UAAU,GAAGlC,MAAM,CAAC,CAAC;QAC3B,IAAIkC,UAAU,IAAIf,eAAe,CAACc,KAAK,EAAE;UACvC,IAAMQ,UAAU,GAAGtD,aAAa,CAAC+C,UAAU,CAAC;UAC5C,IAAME,eAAe,GAAGjD,aAAa,CAACgC,eAAe,CAACc,KAAK,CAAC;UAC5D,IAAMS,QAAQ,GAAGtD,WAAW,CAACgD,eAAe,EAAEK,UAAU,EAAE5C,SAAS,CAACoC,KAAK,CAAC;UAC1E,IAAMU,WAAW,GAAGtD,cAAc,CAAC+C,eAAe,EAAEK,UAAU,EAAE1C,YAAY,CAACkC,KAAK,CAAC;UACnF,IAAIS,QAAQ,KAAKnB,SAAS,IAAID,UAAU,CAACe,GAAG,KAAKK,QAAQ,IAAIC,WAAW,KAAKpB,SAAS,IAAID,UAAU,CAACwB,MAAM,KAAKH,WAAW,EAAE;YAC3H;UACF;QACF;MACF;MACA;MACAI,cAAc,CAAC,CAAC;IAClB,CAAC,CAAC;IACF9B,MAAM,CAAC;MACLmC,cAAc,EAAdA,cAAc;MACdC,kBAAkB,EAAlBA;IACF,CAAC,CAAC;IACF9E,KAAK,CAAC;MAAA,OAAMqC,KAAK,CAACZ,MAAM;IAAA,GAAE,UAAAsD,GAAG,EAAI;MAC/B,IAAMC,SAAS,GAAG,CAACD,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAAC,CAAC,KAAK,IAAI;MAC3E,IAAIjC,KAAK,CAACO,UAAU,KAAK2B,SAAS,EAAE;QAClCrE,mBAAmB,CAAC4C,eAAe,CAAC;QACpC,IAAIyB,SAAS,EAAE;UACbtE,gBAAgB,CAACsE,SAAS,EAAEzB,eAAe,CAAC;UAC5C;UACAsB,cAAc,CAAC,CAAC;QAClB;QACA/B,KAAK,CAACO,UAAU,GAAG2B,SAAS;MAC9B;IACF,CAAC,CAAC;IACFhF,KAAK,CAAC;MAAA,OAAM,CAACqC,KAAK,CAACf,SAAS,EAAEe,KAAK,CAACb,YAAY,CAAC;IAAA,GAAEqD,cAAc,CAAC;IAClE5E,SAAS,CAAC,YAAM;MACd,IACEwB,MAAM,GACJY,KAAK,CADPZ,MAAM;MAER,IAAIA,MAAM,EAAE;QACV;QACA;QACAqB,KAAK,CAACQ,OAAO,GAAG2B,UAAU,CAAC,YAAM;UAC/BvE,gBAAgB,CAACe,MAAM,CAAC,CAAC,EAAE8B,eAAe,CAAC;UAC3C;UACAsB,cAAc,CAAC,CAAC;QAClB,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IACFxE,SAAS,CAAC,YAAM;MACdmD,OAAO,CAAC,CAAC;IACX,CAAC,CAAC;IACFpD,WAAW,CAAC,YAAM;MAChB8E,YAAY,CAACpC,KAAK,CAACQ,OAAO,CAAC;MAC3B3C,mBAAmB,CAAC4C,eAAe,CAAC;MACpCsB,cAAc,CAACM,MAAM,CAAC,CAAC;MACvB;MACAL,kBAAkB,CAACK,MAAM,CAAC,CAAC;IAC7B,CAAC,CAAC;IACF,IAAAC,gBAAA,GAEIrE,eAAe,CAAC,OAAO,EAAEsB,KAAK,CAAC;MADjCT,SAAS,GAAAwD,gBAAA,CAATxD,SAAS;IAEX,IAAAyD,SAAA,GAA0BpE,QAAQ,CAACW,SAAS,CAAC;MAAA0D,UAAA,GAAAC,cAAA,CAAAF,SAAA;MAAtCG,OAAO,GAAAF,UAAA;MAAEG,MAAM,GAAAH,UAAA;IACtB,OAAO,YAAM;MAAA,IAAAI,WAAA;MACX,IAAIC,EAAE;MACN,IACE5C,UAAU,GAERD,KAAK,CAFPC,UAAU;QACVE,gBAAgB,GACdH,KAAK,CADPG,gBAAgB;MAElB,IAAM2C,SAAS,GAAGtF,UAAU,EAAAoF,WAAA,OAAAG,eAAA,CAAAH,WAAA,EACzB9D,SAAS,CAAC8B,KAAK,EAAGX,UAAU,GAAA8C,eAAA,CAAAH,WAAA,EAC5BD,MAAM,CAAC/B,KAAK,EAAG,IAAI,GAAAgC,WAAA,CACrB,CAAC;MACF,IAAMI,SAAS,GAAG9E,IAAI,CAACqB,KAAK,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,cAAc,EAAE,QAAQ,EAAE,UAAU,EAAE,sBAAsB,CAAC,CAAC;MACvH,OAAOmD,OAAO,CAAC5F,YAAY,CAACW,cAAc,EAAE;QAC1C,UAAU,EAAEsE;MACd,CAAC,EAAE;QACD,WAAS,SAAAkB,SAAA;UAAA,OAAM,CAACnG,YAAY,CAAC,KAAK,EAAEH,aAAa,CAACA,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEqG,SAAS,CAAC,EAAEnD,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;YACxG,KAAK,EAAEC;UACT,CAAC,CAAC,EAAE,CAACG,UAAU,IAAInD,YAAY,CAAC,KAAK,EAAE;YACrC,OAAO,EAAEqD,gBAAgB;YACzB,aAAa,EAAE;UACjB,CAAC,EAAE,IAAI,CAAC,EAAErD,YAAY,CAAC,KAAK,EAAE;YAC5B,OAAO,EAAEgG,SAAS;YAClB,KAAK,EAAE/C,SAAS;YAChB,OAAO,EAAEE;UACX,CAAC,EAAE,CAAC,CAAC4C,EAAE,GAAGnD,KAAK,WAAQ,MAAM,IAAI,IAAImD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,IAAI,CAACxD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAAA;MACnF,CAAC,CAAC,CAAC;IACL,CAAC;EACH;AACF,CAAC,CAAC;AACF,eAAe/B,WAAW,CAACuB,KAAK,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}