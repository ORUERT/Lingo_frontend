{"ast":null,"code":"import _classCallCheck from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.number.max-safe-integer.js\";\nimport \"core-js/modules/es.number.min-safe-integer.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.pad-start.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.pad-end.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.repeat.js\";\n/* eslint-disable max-classes-per-file */\nimport { getNumberPrecision, isE, num2str, trimNumber, validateNumber } from './numberUtil';\nimport { supportBigInt } from './supportUtil';\nfunction isEmpty(value) {\n  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();\n}\n/**\n * We can remove this when IE not support anymore\n */\nexport var NumberDecimal = /*#__PURE__*/function () {\n  function NumberDecimal(value) {\n    _classCallCheck(this, NumberDecimal);\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    this.number = Number(value);\n  }\n  _createClass(NumberDecimal, [{\n    key: \"negate\",\n    value: function negate() {\n      return new NumberDecimal(-this.toNumber());\n    }\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      if (this.isInvalidate()) {\n        return new NumberDecimal(value);\n      }\n      var target = Number(value);\n      if (Number.isNaN(target)) {\n        return this;\n      }\n      var number = this.number + target;\n      // [Legacy] Back to safe integer\n      if (number > Number.MAX_SAFE_INTEGER) {\n        return new NumberDecimal(Number.MAX_SAFE_INTEGER);\n      }\n      if (number < Number.MIN_SAFE_INTEGER) {\n        return new NumberDecimal(Number.MIN_SAFE_INTEGER);\n      }\n      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));\n      return new NumberDecimal(number.toFixed(maxPrecision));\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.empty;\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN() {\n      return Number.isNaN(this.number);\n    }\n  }, {\n    key: \"isInvalidate\",\n    value: function isInvalidate() {\n      return this.isEmpty() || this.isNaN();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(target) {\n      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());\n    }\n  }, {\n    key: \"lessEquals\",\n    value: function lessEquals(target) {\n      return this.add(target.negate().toString()).toNumber() <= 0;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.number;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!safe) {\n        return this.origin;\n      }\n      if (this.isInvalidate()) {\n        return '';\n      }\n      return num2str(this.number);\n    }\n  }]);\n  return NumberDecimal;\n}();\nexport var BigIntDecimal = /*#__PURE__*/function () {\n  function BigIntDecimal(value) {\n    _classCallCheck(this, BigIntDecimal);\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    // Act like Number convert\n    if (value === '-' || Number.isNaN(value)) {\n      this.nan = true;\n      return;\n    }\n    var mergedValue = value;\n    // We need convert back to Number since it require `toFixed` to handle this\n    if (isE(mergedValue)) {\n      mergedValue = Number(mergedValue);\n    }\n    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);\n    if (validateNumber(mergedValue)) {\n      var trimRet = trimNumber(mergedValue);\n      this.negative = trimRet.negative;\n      var numbers = trimRet.trimStr.split('.');\n      this.integer = BigInt(numbers[0]);\n      var decimalStr = numbers[1] || '0';\n      this.decimal = BigInt(decimalStr);\n      this.decimalLen = decimalStr.length;\n    } else {\n      this.nan = true;\n    }\n  }\n  _createClass(BigIntDecimal, [{\n    key: \"getMark\",\n    value: function getMark() {\n      return this.negative ? '-' : '';\n    }\n  }, {\n    key: \"getIntegerStr\",\n    value: function getIntegerStr() {\n      return this.integer.toString();\n    }\n  }, {\n    key: \"getDecimalStr\",\n    value: function getDecimalStr() {\n      return this.decimal.toString().padStart(this.decimalLen, '0');\n    }\n    /**\n     * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000\n     * This is used for add function only.\n     */\n  }, {\n    key: \"alignDecimal\",\n    value: function alignDecimal(decimalLength) {\n      var str = \"\".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, '0'));\n      return BigInt(str);\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      var clone = new BigIntDecimal(this.toString());\n      clone.negative = !clone.negative;\n      return clone;\n    }\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      if (this.isInvalidate()) {\n        return new BigIntDecimal(value);\n      }\n      var offset = new BigIntDecimal(value);\n      if (offset.isInvalidate()) {\n        return this;\n      }\n      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);\n      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);\n      var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);\n      var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();\n      // We need fill string length back to `maxDecimalLength` to avoid parser failed\n      var _trimNumber = trimNumber(valueStr),\n        negativeStr = _trimNumber.negativeStr,\n        trimStr = _trimNumber.trimStr;\n      var hydrateValueStr = \"\".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, '0'));\n      return new BigIntDecimal(\"\".concat(hydrateValueStr.slice(0, -maxDecimalLength), \".\").concat(hydrateValueStr.slice(-maxDecimalLength)));\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.empty;\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN() {\n      return this.nan;\n    }\n  }, {\n    key: \"isInvalidate\",\n    value: function isInvalidate() {\n      return this.isEmpty() || this.isNaN();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(target) {\n      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());\n    }\n  }, {\n    key: \"lessEquals\",\n    value: function lessEquals(target) {\n      return this.add(target.negate().toString()).toNumber() <= 0;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      if (this.isNaN()) {\n        return NaN;\n      }\n      return Number(this.toString());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!safe) {\n        return this.origin;\n      }\n      if (this.isInvalidate()) {\n        return '';\n      }\n      return trimNumber(\"\".concat(this.getMark()).concat(this.getIntegerStr(), \".\").concat(this.getDecimalStr())).fullStr;\n    }\n  }]);\n  return BigIntDecimal;\n}();\nexport default function getMiniDecimal(value) {\n  // We use BigInt here.\n  // Will fallback to Number if not support.\n  if (supportBigInt()) {\n    return new BigIntDecimal(value);\n  }\n  return new NumberDecimal(value);\n}\n/**\n * Align the logic of toFixed to around like 1.5 => 2.\n * If set `cutOnly`, will just remove the over decimal part.\n */\nexport function toFixed(numStr, separatorStr, precision) {\n  var cutOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (numStr === '') {\n    return '';\n  }\n  var _trimNumber2 = trimNumber(numStr),\n    negativeStr = _trimNumber2.negativeStr,\n    integerStr = _trimNumber2.integerStr,\n    decimalStr = _trimNumber2.decimalStr;\n  var precisionDecimalStr = \"\".concat(separatorStr).concat(decimalStr);\n  var numberWithoutDecimal = \"\".concat(negativeStr).concat(integerStr);\n  if (precision >= 0) {\n    // We will get last + 1 number to check if need advanced number\n    var advancedNum = Number(decimalStr[precision]);\n    if (advancedNum >= 5 && !cutOnly) {\n      var advancedDecimal = getMiniDecimal(numStr).add(\"\".concat(negativeStr, \"0.\").concat('0'.repeat(precision)).concat(10 - advancedNum));\n      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);\n    }\n    if (precision === 0) {\n      return numberWithoutDecimal;\n    }\n    return \"\".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, '0').slice(0, precision));\n  }\n  if (precisionDecimalStr === '.0') {\n    return numberWithoutDecimal;\n  }\n  return \"\".concat(numberWithoutDecimal).concat(precisionDecimalStr);\n}","map":{"version":3,"names":["getNumberPrecision","isE","num2str","trimNumber","validateNumber","supportBigInt","isEmpty","value","Number","isNaN","String","trim","NumberDecimal","_classCallCheck","origin","empty","number","_createClass","key","negate","toNumber","add","isInvalidate","target","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","maxPrecision","Math","max","toFixed","equals","lessEquals","toString","safe","arguments","length","undefined","BigIntDecimal","nan","mergedValue","trimRet","negative","numbers","trimStr","split","integer","BigInt","decimalStr","decimal","decimalLen","getMark","getIntegerStr","getDecimalStr","padStart","alignDecimal","decimalLength","str","concat","padEnd","clone","offset","maxDecimalLength","myAlignedDecimal","offsetAlignedDecimal","valueStr","_trimNumber","negativeStr","hydrateValueStr","slice","NaN","fullStr","getMiniDecimal","numStr","separatorStr","precision","cutOnly","_trimNumber2","integerStr","precisionDecimalStr","numberWithoutDecimal","advancedNum","advancedDecimal","repeat"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/input-number/src/utils/MiniDecimal.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\nimport { getNumberPrecision, isE, num2str, trimNumber, validateNumber } from './numberUtil';\nimport { supportBigInt } from './supportUtil';\nfunction isEmpty(value) {\n  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();\n}\n/**\n * We can remove this when IE not support anymore\n */\nexport class NumberDecimal {\n  constructor(value) {\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    this.number = Number(value);\n  }\n  negate() {\n    return new NumberDecimal(-this.toNumber());\n  }\n  add(value) {\n    if (this.isInvalidate()) {\n      return new NumberDecimal(value);\n    }\n    const target = Number(value);\n    if (Number.isNaN(target)) {\n      return this;\n    }\n    const number = this.number + target;\n    // [Legacy] Back to safe integer\n    if (number > Number.MAX_SAFE_INTEGER) {\n      return new NumberDecimal(Number.MAX_SAFE_INTEGER);\n    }\n    if (number < Number.MIN_SAFE_INTEGER) {\n      return new NumberDecimal(Number.MIN_SAFE_INTEGER);\n    }\n    const maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));\n    return new NumberDecimal(number.toFixed(maxPrecision));\n  }\n  isEmpty() {\n    return this.empty;\n  }\n  isNaN() {\n    return Number.isNaN(this.number);\n  }\n  isInvalidate() {\n    return this.isEmpty() || this.isNaN();\n  }\n  equals(target) {\n    return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());\n  }\n  lessEquals(target) {\n    return this.add(target.negate().toString()).toNumber() <= 0;\n  }\n  toNumber() {\n    return this.number;\n  }\n  toString() {\n    let safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!safe) {\n      return this.origin;\n    }\n    if (this.isInvalidate()) {\n      return '';\n    }\n    return num2str(this.number);\n  }\n}\nexport class BigIntDecimal {\n  constructor(value) {\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    // Act like Number convert\n    if (value === '-' || Number.isNaN(value)) {\n      this.nan = true;\n      return;\n    }\n    let mergedValue = value;\n    // We need convert back to Number since it require `toFixed` to handle this\n    if (isE(mergedValue)) {\n      mergedValue = Number(mergedValue);\n    }\n    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);\n    if (validateNumber(mergedValue)) {\n      const trimRet = trimNumber(mergedValue);\n      this.negative = trimRet.negative;\n      const numbers = trimRet.trimStr.split('.');\n      this.integer = BigInt(numbers[0]);\n      const decimalStr = numbers[1] || '0';\n      this.decimal = BigInt(decimalStr);\n      this.decimalLen = decimalStr.length;\n    } else {\n      this.nan = true;\n    }\n  }\n  getMark() {\n    return this.negative ? '-' : '';\n  }\n  getIntegerStr() {\n    return this.integer.toString();\n  }\n  getDecimalStr() {\n    return this.decimal.toString().padStart(this.decimalLen, '0');\n  }\n  /**\n   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000\n   * This is used for add function only.\n   */\n  alignDecimal(decimalLength) {\n    const str = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(decimalLength, '0')}`;\n    return BigInt(str);\n  }\n  negate() {\n    const clone = new BigIntDecimal(this.toString());\n    clone.negative = !clone.negative;\n    return clone;\n  }\n  add(value) {\n    if (this.isInvalidate()) {\n      return new BigIntDecimal(value);\n    }\n    const offset = new BigIntDecimal(value);\n    if (offset.isInvalidate()) {\n      return this;\n    }\n    const maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);\n    const myAlignedDecimal = this.alignDecimal(maxDecimalLength);\n    const offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);\n    const valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();\n    // We need fill string length back to `maxDecimalLength` to avoid parser failed\n    const {\n      negativeStr,\n      trimStr\n    } = trimNumber(valueStr);\n    const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;\n    return new BigIntDecimal(`${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`);\n  }\n  isEmpty() {\n    return this.empty;\n  }\n  isNaN() {\n    return this.nan;\n  }\n  isInvalidate() {\n    return this.isEmpty() || this.isNaN();\n  }\n  equals(target) {\n    return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());\n  }\n  lessEquals(target) {\n    return this.add(target.negate().toString()).toNumber() <= 0;\n  }\n  toNumber() {\n    if (this.isNaN()) {\n      return NaN;\n    }\n    return Number(this.toString());\n  }\n  toString() {\n    let safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!safe) {\n      return this.origin;\n    }\n    if (this.isInvalidate()) {\n      return '';\n    }\n    return trimNumber(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr;\n  }\n}\nexport default function getMiniDecimal(value) {\n  // We use BigInt here.\n  // Will fallback to Number if not support.\n  if (supportBigInt()) {\n    return new BigIntDecimal(value);\n  }\n  return new NumberDecimal(value);\n}\n/**\n * Align the logic of toFixed to around like 1.5 => 2.\n * If set `cutOnly`, will just remove the over decimal part.\n */\nexport function toFixed(numStr, separatorStr, precision) {\n  let cutOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (numStr === '') {\n    return '';\n  }\n  const {\n    negativeStr,\n    integerStr,\n    decimalStr\n  } = trimNumber(numStr);\n  const precisionDecimalStr = `${separatorStr}${decimalStr}`;\n  const numberWithoutDecimal = `${negativeStr}${integerStr}`;\n  if (precision >= 0) {\n    // We will get last + 1 number to check if need advanced number\n    const advancedNum = Number(decimalStr[precision]);\n    if (advancedNum >= 5 && !cutOnly) {\n      const advancedDecimal = getMiniDecimal(numStr).add(`${negativeStr}0.${'0'.repeat(precision)}${10 - advancedNum}`);\n      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);\n    }\n    if (precision === 0) {\n      return numberWithoutDecimal;\n    }\n    return `${numberWithoutDecimal}${separatorStr}${decimalStr.padEnd(precision, '0').slice(0, precision)}`;\n  }\n  if (precisionDecimalStr === '.0') {\n    return numberWithoutDecimal;\n  }\n  return `${numberWithoutDecimal}${precisionDecimalStr}`;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}