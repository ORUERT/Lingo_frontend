{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { createApp } from 'vue';\n// We only handle element & text node.\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar ellipsisContainer;\nvar wrapperStyle = {\n  padding: 0,\n  margin: 0,\n  display: 'inline',\n  lineHeight: 'inherit'\n};\nfunction styleToString(style) {\n  // There are some different behavior between Firefox & Chrome.\n  // We have to handle this ourself.\n  var styleNames = Array.prototype.slice.apply(style);\n  return styleNames.map(function (name) {\n    return \"\".concat(name, \": \").concat(style.getPropertyValue(name), \";\");\n  }).join('');\n}\nfunction resetDomStyles(target, origin) {\n  target.setAttribute('aria-hidden', 'true');\n  var originStyle = window.getComputedStyle(origin);\n  var originCSS = styleToString(originStyle);\n  // Set shadow\n  target.setAttribute('style', originCSS);\n  target.style.position = 'fixed';\n  target.style.left = '0';\n  target.style.height = 'auto';\n  target.style.minHeight = 'auto';\n  target.style.maxHeight = 'auto';\n  target.style.paddingTop = '0';\n  target.style.paddingBottom = '0';\n  target.style.borderTopWidth = '0';\n  target.style.borderBottomWidth = '0';\n  target.style.top = '-999999px';\n  target.style.zIndex = '-1000';\n  // clean up css overflow\n  target.style.textOverflow = 'clip';\n  target.style.whiteSpace = 'normal';\n  target.style.webkitLineClamp = 'none';\n}\nfunction getRealLineHeight(originElement) {\n  var heightContainer = document.createElement('div');\n  resetDomStyles(heightContainer, originElement);\n  heightContainer.appendChild(document.createTextNode('text'));\n  document.body.appendChild(heightContainer);\n  // The element real height is always less than multiple of line-height\n  // Use getBoundingClientRect to get actual single row height of the element\n  var realHeight = heightContainer.getBoundingClientRect().height;\n  document.body.removeChild(heightContainer);\n  return realHeight;\n}\nexport default (function (originElement, option, content, fixedContent, ellipsisStr) {\n  if (!ellipsisContainer) {\n    ellipsisContainer = document.createElement('div');\n    ellipsisContainer.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(ellipsisContainer);\n  }\n  var rows = option.rows,\n    _option$suffix = option.suffix,\n    suffix = _option$suffix === void 0 ? '' : _option$suffix;\n  var lineHeight = getRealLineHeight(originElement);\n  var maxHeight = Math.round(lineHeight * rows * 100) / 100;\n  resetDomStyles(ellipsisContainer, originElement);\n  // Render in the fake container\n  var vm = createApp({\n    render: function render() {\n      return _createVNode(\"div\", {\n        \"style\": wrapperStyle\n      }, [_createVNode(\"span\", {\n        \"style\": wrapperStyle\n      }, [content, suffix]), _createVNode(\"span\", {\n        \"style\": wrapperStyle\n      }, [fixedContent])]);\n    }\n  });\n  vm.mount(ellipsisContainer);\n  // Check if ellipsis in measure div is height enough for content\n  function inRange() {\n    var currentHeight = Math.round(ellipsisContainer.getBoundingClientRect().height * 100) / 100;\n    return currentHeight - 0.1 <= maxHeight; // -.1 for firefox\n  }\n  // Skip ellipsis if already match\n  if (inRange()) {\n    vm.unmount();\n    return {\n      content: content,\n      text: ellipsisContainer.innerHTML,\n      ellipsis: false\n    };\n  }\n  var childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter(function (_ref) {\n    var nodeType = _ref.nodeType,\n      data = _ref.data;\n    return nodeType !== COMMENT_NODE && data !== '';\n  });\n  var fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n  vm.unmount();\n  // ========================= Find match ellipsis content =========================\n  var ellipsisChildren = [];\n  ellipsisContainer.innerHTML = '';\n  // Create origin content holder\n  var ellipsisContentHolder = document.createElement('span');\n  ellipsisContainer.appendChild(ellipsisContentHolder);\n  var ellipsisTextNode = document.createTextNode(ellipsisStr + suffix);\n  ellipsisContentHolder.appendChild(ellipsisTextNode);\n  fixedNodes.forEach(function (childNode) {\n    ellipsisContainer.appendChild(childNode);\n  });\n  // Append before fixed nodes\n  function appendChildNode(node) {\n    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n  }\n  // Get maximum text\n  function measureText(textNode, fullText) {\n    var startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;\n    var lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var midLoc = Math.floor((startLoc + endLoc) / 2);\n    var currentText = fullText.slice(0, midLoc);\n    textNode.textContent = currentText;\n    if (startLoc >= endLoc - 1) {\n      // Loop when step is small\n      for (var step = endLoc; step >= startLoc; step -= 1) {\n        var currentStepText = fullText.slice(0, step);\n        textNode.textContent = currentStepText;\n        if (inRange() || !currentStepText) {\n          return step === fullText.length ? {\n            finished: false,\n            vNode: fullText\n          } : {\n            finished: true,\n            vNode: currentStepText\n          };\n        }\n      }\n    }\n    if (inRange()) {\n      return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n    }\n    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n  }\n  function measureNode(childNode) {\n    var type = childNode.nodeType;\n    // console.log('type', type);\n    // if (type === ELEMENT_NODE) {\n    //   // We don't split element, it will keep if whole element can be displayed.\n    //   appendChildNode(childNode);\n    //   if (inRange()) {\n    //     return {\n    //       finished: false,\n    //       vNode: contentList[index],\n    //     };\n    //   }\n    //   // Clean up if can not pull in\n    //   ellipsisContentHolder.removeChild(childNode);\n    //   return {\n    //     finished: true,\n    //     vNode: null,\n    //   };\n    // }\n    if (type === TEXT_NODE) {\n      var fullText = childNode.textContent || '';\n      var textNode = document.createTextNode(fullText);\n      appendChildNode(textNode);\n      return measureText(textNode, fullText);\n    }\n    // Not handle other type of content\n    return {\n      finished: false,\n      vNode: null\n    };\n  }\n  childNodes.some(function (childNode) {\n    var _measureNode = measureNode(childNode),\n      finished = _measureNode.finished,\n      vNode = _measureNode.vNode;\n    if (vNode) {\n      ellipsisChildren.push(vNode);\n    }\n    return finished;\n  });\n  return {\n    content: ellipsisChildren,\n    text: ellipsisContainer.innerHTML,\n    ellipsis: true\n  };\n});","map":{"version":3,"names":["createVNode","_createVNode","createApp","TEXT_NODE","COMMENT_NODE","ellipsisContainer","wrapperStyle","padding","margin","display","lineHeight","styleToString","style","styleNames","Array","prototype","slice","apply","map","name","concat","getPropertyValue","join","resetDomStyles","target","origin","setAttribute","originStyle","window","getComputedStyle","originCSS","position","left","height","minHeight","maxHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","top","zIndex","textOverflow","whiteSpace","webkitLineClamp","getRealLineHeight","originElement","heightContainer","document","createElement","appendChild","createTextNode","body","realHeight","getBoundingClientRect","removeChild","option","content","fixedContent","ellipsisStr","rows","_option$suffix","suffix","Math","round","vm","render","mount","inRange","currentHeight","unmount","text","innerHTML","ellipsis","childNodes","cloneNode","filter","_ref","nodeType","data","fixedNodes","ellipsisChildren","ellipsisContentHolder","ellipsisTextNode","forEach","childNode","appendChildNode","node","insertBefore","measureText","textNode","fullText","startLoc","arguments","length","undefined","endLoc","lastSuccessLoc","midLoc","floor","currentText","textContent","step","currentStepText","finished","vNode","measureNode","type","some","_measureNode","push"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/typography/util.js"],"sourcesContent":["import { createVNode as _createVNode } from \"vue\";\nimport { createApp } from 'vue';\n// We only handle element & text node.\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nlet ellipsisContainer;\nconst wrapperStyle = {\n  padding: 0,\n  margin: 0,\n  display: 'inline',\n  lineHeight: 'inherit'\n};\nfunction styleToString(style) {\n  // There are some different behavior between Firefox & Chrome.\n  // We have to handle this ourself.\n  const styleNames = Array.prototype.slice.apply(style);\n  return styleNames.map(name => `${name}: ${style.getPropertyValue(name)};`).join('');\n}\nfunction resetDomStyles(target, origin) {\n  target.setAttribute('aria-hidden', 'true');\n  const originStyle = window.getComputedStyle(origin);\n  const originCSS = styleToString(originStyle);\n  // Set shadow\n  target.setAttribute('style', originCSS);\n  target.style.position = 'fixed';\n  target.style.left = '0';\n  target.style.height = 'auto';\n  target.style.minHeight = 'auto';\n  target.style.maxHeight = 'auto';\n  target.style.paddingTop = '0';\n  target.style.paddingBottom = '0';\n  target.style.borderTopWidth = '0';\n  target.style.borderBottomWidth = '0';\n  target.style.top = '-999999px';\n  target.style.zIndex = '-1000';\n  // clean up css overflow\n  target.style.textOverflow = 'clip';\n  target.style.whiteSpace = 'normal';\n  target.style.webkitLineClamp = 'none';\n}\nfunction getRealLineHeight(originElement) {\n  const heightContainer = document.createElement('div');\n  resetDomStyles(heightContainer, originElement);\n  heightContainer.appendChild(document.createTextNode('text'));\n  document.body.appendChild(heightContainer);\n  // The element real height is always less than multiple of line-height\n  // Use getBoundingClientRect to get actual single row height of the element\n  const realHeight = heightContainer.getBoundingClientRect().height;\n  document.body.removeChild(heightContainer);\n  return realHeight;\n}\nexport default ((originElement, option, content, fixedContent, ellipsisStr) => {\n  if (!ellipsisContainer) {\n    ellipsisContainer = document.createElement('div');\n    ellipsisContainer.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(ellipsisContainer);\n  }\n  const {\n    rows,\n    suffix = ''\n  } = option;\n  const lineHeight = getRealLineHeight(originElement);\n  const maxHeight = Math.round(lineHeight * rows * 100) / 100;\n  resetDomStyles(ellipsisContainer, originElement);\n  // Render in the fake container\n  const vm = createApp({\n    render() {\n      return _createVNode(\"div\", {\n        \"style\": wrapperStyle\n      }, [_createVNode(\"span\", {\n        \"style\": wrapperStyle\n      }, [content, suffix]), _createVNode(\"span\", {\n        \"style\": wrapperStyle\n      }, [fixedContent])]);\n    }\n  });\n  vm.mount(ellipsisContainer);\n  // Check if ellipsis in measure div is height enough for content\n  function inRange() {\n    const currentHeight = Math.round(ellipsisContainer.getBoundingClientRect().height * 100) / 100;\n    return currentHeight - 0.1 <= maxHeight; // -.1 for firefox\n  }\n  // Skip ellipsis if already match\n  if (inRange()) {\n    vm.unmount();\n    return {\n      content,\n      text: ellipsisContainer.innerHTML,\n      ellipsis: false\n    };\n  }\n  const childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter(_ref => {\n    let {\n      nodeType,\n      data\n    } = _ref;\n    return nodeType !== COMMENT_NODE && data !== '';\n  });\n  const fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n  vm.unmount();\n  // ========================= Find match ellipsis content =========================\n  const ellipsisChildren = [];\n  ellipsisContainer.innerHTML = '';\n  // Create origin content holder\n  const ellipsisContentHolder = document.createElement('span');\n  ellipsisContainer.appendChild(ellipsisContentHolder);\n  const ellipsisTextNode = document.createTextNode(ellipsisStr + suffix);\n  ellipsisContentHolder.appendChild(ellipsisTextNode);\n  fixedNodes.forEach(childNode => {\n    ellipsisContainer.appendChild(childNode);\n  });\n  // Append before fixed nodes\n  function appendChildNode(node) {\n    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n  }\n  // Get maximum text\n  function measureText(textNode, fullText) {\n    let startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;\n    let lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const midLoc = Math.floor((startLoc + endLoc) / 2);\n    const currentText = fullText.slice(0, midLoc);\n    textNode.textContent = currentText;\n    if (startLoc >= endLoc - 1) {\n      // Loop when step is small\n      for (let step = endLoc; step >= startLoc; step -= 1) {\n        const currentStepText = fullText.slice(0, step);\n        textNode.textContent = currentStepText;\n        if (inRange() || !currentStepText) {\n          return step === fullText.length ? {\n            finished: false,\n            vNode: fullText\n          } : {\n            finished: true,\n            vNode: currentStepText\n          };\n        }\n      }\n    }\n    if (inRange()) {\n      return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n    }\n    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n  }\n  function measureNode(childNode) {\n    const type = childNode.nodeType;\n    // console.log('type', type);\n    // if (type === ELEMENT_NODE) {\n    //   // We don't split element, it will keep if whole element can be displayed.\n    //   appendChildNode(childNode);\n    //   if (inRange()) {\n    //     return {\n    //       finished: false,\n    //       vNode: contentList[index],\n    //     };\n    //   }\n    //   // Clean up if can not pull in\n    //   ellipsisContentHolder.removeChild(childNode);\n    //   return {\n    //     finished: true,\n    //     vNode: null,\n    //   };\n    // }\n    if (type === TEXT_NODE) {\n      const fullText = childNode.textContent || '';\n      const textNode = document.createTextNode(fullText);\n      appendChildNode(textNode);\n      return measureText(textNode, fullText);\n    }\n    // Not handle other type of content\n    return {\n      finished: false,\n      vNode: null\n    };\n  }\n  childNodes.some(childNode => {\n    const {\n      finished,\n      vNode\n    } = measureNode(childNode);\n    if (vNode) {\n      ellipsisChildren.push(vNode);\n    }\n    return finished;\n  });\n  return {\n    content: ellipsisChildren,\n    text: ellipsisContainer.innerHTML,\n    ellipsis: true\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}