{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { note } from '../../vc-util/warning';\nfunction removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {\n  var filteredKeys = new Set();\n  halfCheckedKeys.forEach(function (key) {\n    if (!checkedKeys.has(key)) {\n      filteredKeys.add(key);\n    }\n  });\n  return filteredKeys;\n}\nexport function isCheckDisabled(node) {\n  var _ref3 = node || {},\n    disabled = _ref3.disabled,\n    disableCheckbox = _ref3.disableCheckbox,\n    checkable = _ref3.checkable;\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n// Fill miss keys\nfunction fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  var checkedKeys = new Set(keys);\n  var halfCheckedKeys = new Set();\n  // Add checked keys top to bottom\n  for (var level = 0; level <= maxLevel; level += 1) {\n    var entities = levelEntities.get(level) || new Set();\n    entities.forEach(function (entity) {\n      var key = entity.key,\n        node = entity.node,\n        _entity$children = entity.children,\n        children = _entity$children === void 0 ? [] : _entity$children;\n      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(function (childEntity) {\n          return !syntheticGetCheckDisabled(childEntity.node);\n        }).forEach(function (childEntity) {\n          checkedKeys.add(childEntity.key);\n        });\n      }\n    });\n  }\n  // Add checked keys from bottom to top\n  var visitedKeys = new Set();\n  for (var _level = maxLevel; _level >= 0; _level -= 1) {\n    var _entities = levelEntities.get(_level) || new Set();\n    _entities.forEach(function (entity) {\n      var parent = entity.parent,\n        node = entity.node;\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      var allChecked = true;\n      var partialChecked = false;\n      (parent.children || []).filter(function (childEntity) {\n        return !syntheticGetCheckDisabled(childEntity.node);\n      }).forEach(function (_ref) {\n        var key = _ref.key;\n        var checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (allChecked) {\n        checkedKeys.add(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n// Remove useless key\nfunction cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  var checkedKeys = new Set(keys);\n  var halfCheckedKeys = new Set(halfKeys);\n  // Remove checked keys from top to bottom\n  for (var level = 0; level <= maxLevel; level += 1) {\n    var entities = levelEntities.get(level) || new Set();\n    entities.forEach(function (entity) {\n      var key = entity.key,\n        node = entity.node,\n        _entity$children2 = entity.children,\n        children = _entity$children2 === void 0 ? [] : _entity$children2;\n      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(function (childEntity) {\n          return !syntheticGetCheckDisabled(childEntity.node);\n        }).forEach(function (childEntity) {\n          checkedKeys[\"delete\"](childEntity.key);\n        });\n      }\n    });\n  }\n  // Remove checked keys form bottom to top\n  halfCheckedKeys = new Set();\n  var visitedKeys = new Set();\n  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {\n    var _entities2 = levelEntities.get(_level2) || new Set();\n    _entities2.forEach(function (entity) {\n      var parent = entity.parent,\n        node = entity.node;\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      var allChecked = true;\n      var partialChecked = false;\n      (parent.children || []).filter(function (childEntity) {\n        return !syntheticGetCheckDisabled(childEntity.node);\n      }).forEach(function (_ref2) {\n        var key = _ref2.key;\n        var checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (!allChecked) {\n        checkedKeys[\"delete\"](parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n/**\n * Conduct with keys.\n * @param keyList current key list\n * @param keyEntities key - dataEntity map\n * @param mode `fill` to fill missing key, `clean` to remove useless key\n */\nexport function conductCheck(keyList, checked, keyEntities, maxLevel, levelEntities, getCheckDisabled) {\n  var warningMissKeys = [];\n  var syntheticGetCheckDisabled;\n  if (getCheckDisabled) {\n    syntheticGetCheckDisabled = getCheckDisabled;\n  } else {\n    syntheticGetCheckDisabled = isCheckDisabled;\n  }\n  // We only handle exist keys\n  var keys = new Set(keyList.filter(function (key) {\n    var hasEntity = !!keyEntities[key];\n    if (!hasEntity) {\n      warningMissKeys.push(key);\n    }\n    return hasEntity;\n  }));\n  note(!warningMissKeys.length, \"Tree missing follow keys: \".concat(warningMissKeys.slice(0, 100).map(function (key) {\n    return \"'\".concat(key, \"'\");\n  }).join(', ')));\n  var result;\n  if (checked === true) {\n    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  } else {\n    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  }\n  return result;\n}","map":{"version":3,"names":["note","removeFromCheckedKeys","halfCheckedKeys","checkedKeys","filteredKeys","Set","forEach","key","has","add","isCheckDisabled","node","_ref3","disabled","disableCheckbox","checkable","fillConductCheck","keys","levelEntities","maxLevel","syntheticGetCheckDisabled","level","entities","get","entity","_entity$children","children","filter","childEntity","visitedKeys","parent","allChecked","partialChecked","_ref","checked","Array","from","cleanConductCheck","halfKeys","_entity$children2","_ref2","conductCheck","keyList","keyEntities","getCheckDisabled","warningMissKeys","hasEntity","push","length","concat","slice","map","join","result"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/vc-tree/utils/conductUtil.js"],"sourcesContent":["import { note } from '../../vc-util/warning';\nfunction removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {\n  const filteredKeys = new Set();\n  halfCheckedKeys.forEach(key => {\n    if (!checkedKeys.has(key)) {\n      filteredKeys.add(key);\n    }\n  });\n  return filteredKeys;\n}\nexport function isCheckDisabled(node) {\n  const {\n    disabled,\n    disableCheckbox,\n    checkable\n  } = node || {};\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n// Fill miss keys\nfunction fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  const halfCheckedKeys = new Set();\n  // Add checked keys top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.add(childEntity.key);\n        });\n      }\n    });\n  }\n  // Add checked keys from bottom to top\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(_ref => {\n        let {\n          key\n        } = _ref;\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (allChecked) {\n        checkedKeys.add(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n// Remove useless key\nfunction cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  let halfCheckedKeys = new Set(halfKeys);\n  // Remove checked keys from top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.delete(childEntity.key);\n        });\n      }\n    });\n  }\n  // Remove checked keys form bottom to top\n  halfCheckedKeys = new Set();\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(_ref2 => {\n        let {\n          key\n        } = _ref2;\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (!allChecked) {\n        checkedKeys.delete(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n/**\n * Conduct with keys.\n * @param keyList current key list\n * @param keyEntities key - dataEntity map\n * @param mode `fill` to fill missing key, `clean` to remove useless key\n */\nexport function conductCheck(keyList, checked, keyEntities, maxLevel, levelEntities, getCheckDisabled) {\n  const warningMissKeys = [];\n  let syntheticGetCheckDisabled;\n  if (getCheckDisabled) {\n    syntheticGetCheckDisabled = getCheckDisabled;\n  } else {\n    syntheticGetCheckDisabled = isCheckDisabled;\n  }\n  // We only handle exist keys\n  const keys = new Set(keyList.filter(key => {\n    const hasEntity = !!keyEntities[key];\n    if (!hasEntity) {\n      warningMissKeys.push(key);\n    }\n    return hasEntity;\n  }));\n  note(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map(key => `'${key}'`).join(', ')}`);\n  let result;\n  if (checked === true) {\n    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  } else {\n    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  }\n  return result;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}