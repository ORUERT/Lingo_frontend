{"ast":null,"code":"import _toConsumableArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _typeof from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { toArray } from './typeUtil';\nimport get from '../../vc-util/get';\nimport set from '../../vc-util/set';\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\nexport function getValue(store, namePath) {\n  var value = get(store, namePath);\n  return value;\n}\nexport function setValue(store, namePath, value) {\n  var removeIfUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var newStore = set(store, namePath, value, removeIfUndefined);\n  return newStore;\n}\nexport function containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(function (path) {\n    return matchNamePath(path, namePath);\n  });\n}\nfunction isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Copy values into store and return a new values object\n * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }\n */\nfunction internalSetValues(store, values) {\n  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _extends({}, store);\n  if (!values) {\n    return newStore;\n  }\n  Object.keys(values).forEach(function (key) {\n    var prevValue = newStore[key];\n    var value = values[key];\n    // If both are object (but target is not array), we use recursion to set deep value\n    var recursive = isObject(prevValue) && isObject(value);\n    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\nexport function setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n  return restValues.reduce(function (current, newStore) {\n    return internalSetValues(current, newStore);\n  }, store);\n}\nexport function cloneByNamePathList(store, namePathList) {\n  var newStore = {};\n  namePathList.forEach(function (namePath) {\n    var value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\nexport function matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n  return namePath.every(function (nameUnit, i) {\n    return changedNamePath[i] === nameUnit;\n  });\n}","map":{"version":3,"names":["_extends","toArray","get","set","getNamePath","path","getValue","store","namePath","value","setValue","removeIfUndefined","arguments","length","undefined","newStore","containsNamePath","namePathList","some","matchNamePath","isObject","obj","_typeof","Object","getPrototypeOf","prototype","internalSetValues","values","Array","isArray","_toConsumableArray","keys","forEach","key","prevValue","recursive","setValues","_len","restValues","_key","reduce","current","cloneByNamePathList","changedNamePath","every","nameUnit","i"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/form/utils/valueUtil.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { toArray } from './typeUtil';\nimport get from '../../vc-util/get';\nimport set from '../../vc-util/set';\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\nexport function getValue(store, namePath) {\n  const value = get(store, namePath);\n  return value;\n}\nexport function setValue(store, namePath, value) {\n  let removeIfUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const newStore = set(store, namePath, value, removeIfUndefined);\n  return newStore;\n}\nexport function containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(path => matchNamePath(path, namePath));\n}\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Copy values into store and return a new values object\n * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }\n */\nfunction internalSetValues(store, values) {\n  const newStore = Array.isArray(store) ? [...store] : _extends({}, store);\n  if (!values) {\n    return newStore;\n  }\n  Object.keys(values).forEach(key => {\n    const prevValue = newStore[key];\n    const value = values[key];\n    // If both are object (but target is not array), we use recursion to set deep value\n    const recursive = isObject(prevValue) && isObject(value);\n    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\nexport function setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n  return restValues.reduce((current, newStore) => internalSetValues(current, newStore), store);\n}\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\nexport function matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n  return namePath.every((nameUnit, i) => changedNamePath[i] === nameUnit);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}