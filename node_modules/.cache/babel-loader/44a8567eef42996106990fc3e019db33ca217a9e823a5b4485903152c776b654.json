{"ast":null,"code":"import _defineProperty from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n    handle = _ref.handle,\n    bounds = _ref.bounds,\n    props = _ref.props;\n  var allowCross = props.allowCross,\n    pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  disabled: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  reverse: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    \"default\": undefined\n  }\n};\nvar Range = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data: function data() {\n    var _this = this;\n    var count = this.count,\n      min = this.min,\n      max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n    if (value === undefined) {\n      value = defaultValue;\n    }\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: _this2.$props\n          });\n        });\n      }\n      this.setState({\n        bounds: nextBounds\n      });\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      var data = _extends(_extends({}, this.$data), state);\n      var changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue: function positionGetValue(position) {\n      var bounds = this.getValue();\n      var value = this.calcValueByPos(position);\n      var closestBound = this.getClosestBound(value);\n      var index = this.getBoundNeedMoving(value, closestBound);\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n      this.$emit('beforeChange', bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.$data,\n        props = this.$props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      var bounds = this.bounds,\n        sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n        reverse = _this$$props.reverse,\n        vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n          sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n        recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n        step = this.step,\n        min = this.min,\n        max = this.max;\n      var cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n      return this.internalPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n      var nextBounds = _toConsumableArray(this.bounds);\n      var sHandle = this.sHandle,\n        recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n        bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n        thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n        prefixCls = _ref3.prefixCls,\n        reverse = _ref3.reverse,\n        vertical = _ref3.vertical,\n        included = _ref3.included,\n        offsets = _ref3.offsets,\n        trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n      var sHandle = this.sHandle,\n        bounds = this.bounds,\n        prefixCls = this.prefixCls,\n        vertical = this.vertical,\n        included = this.included,\n        disabled = this.disabled,\n        min = this.min,\n        max = this.max,\n        reverse = this.reverse,\n        handle = this.handle,\n        defaultHandle = this.defaultHandle,\n        trackStyle = this.trackStyle,\n        handleStyle = this.handleStyle,\n        tabindex = this.tabindex,\n        ariaLabelGroupForHandles = this.ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles = this.ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles = this.ariaValueTextFormatterGroupForHandles;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n        var mergedTabIndex = tabindex[i] || 0;\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n        var dragging = sHandle === i;\n        return handleGenerator({\n          \"class\": classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);","map":{"version":3,"names":["_extends","createVNode","_createVNode","classNames","PropTypes","withUndefined","BaseMixin","hasProp","Track","createSlider","utils","initDefaultProps","defineComponent","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","rangeProps","defaultValue","arrayOf","number","count","oneOfType","looseBool","type","Boolean","disabled","reverse","tabindex","prefixCls","String","min","max","autofocus","ariaLabelGroupForHandles","Array","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","draggableTrack","Range","compatConfig","MODE","name","mixins","inheritAttrs","emits","displayName","data","_this","initialValue","apply","_toConsumableArray","map","v","i","$props","recent","sHandle","watch","handler","val","setChangeValue","deep","methods","_this2","nextBounds","every","setState","some","isValueOutOfRange","newValues","$emit","onChange","state","isNotControlled","controlledState","forEach","item","Object","keys","$data","changedValue","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","onStart","startValue","startPosition","prevMovedHandleIndex","onEnd","force","removeDocumentEvents","dragTrack","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","Math","ratio","getSliderLength","floor","c","oldValue","moveTo","onKeyboard","_this$$props","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","ensureValueNotConflict","_ref2","getTrack","_ref3","included","offsets","trackStyle","slice","_","_classNames","trackClassName","_defineProperty","concat","renderSlider","_this4","defaultHandle","handleStyle","handleGenerator","calcOffset","handleClassName","handles","_classNames2","mergedTabIndex","dragging","offset","style","ref","h","saveHandle","onFocus","onBlur","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/vc-slider/src/Range.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\nconst trimAlignValue = _ref => {\n  let {\n    value,\n    handle,\n    bounds,\n    props\n  } = _ref;\n  const {\n    allowCross,\n    pushable\n  } = props;\n  const thershold = Number(pushable);\n  const valInRange = utils.ensureValueInRange(value, props);\n  let valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nconst rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    default: undefined\n  },\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  reverse: {\n    type: Boolean,\n    default: undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    default: undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    default: undefined\n  }\n};\nconst Range = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data() {\n    const {\n      count,\n      min,\n      max\n    } = this;\n    const initialValue = Array(...Array(count + 1)).map(() => min);\n    const defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    let {\n      value\n    } = this;\n    if (value === undefined) {\n      value = defaultValue;\n    }\n    const bounds = value.map((v, i) => trimAlignValue({\n      value: v,\n      handle: i,\n      props: this.$props\n    }));\n    const recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent,\n      bounds\n    };\n  },\n  watch: {\n    value: {\n      handler(val) {\n        const {\n          bounds\n        } = this;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min() {\n      const {\n        value\n      } = this;\n      this.setChangeValue(value || this.bounds);\n    },\n    max() {\n      const {\n        value\n      } = this;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue(value) {\n      const {\n        bounds\n      } = this;\n      let nextBounds = value.map((v, i) => trimAlignValue({\n        value: v,\n        handle: i,\n        bounds,\n        props: this.$props\n      }));\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every((v, i) => v === bounds[i])) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map((v, i) => trimAlignValue({\n          value: v,\n          handle: i,\n          props: this.$props\n        }));\n      }\n      this.setState({\n        bounds: nextBounds\n      });\n      if (value.some(v => utils.isValueOutOfRange(v, this.$props))) {\n        const newValues = value.map(v => {\n          return utils.ensureValueInRange(v, this.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange(state) {\n      const isNotControlled = !hasProp(this, 'value');\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        const controlledState = {};\n        ['sHandle', 'recent'].forEach(item => {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      const data = _extends(_extends({}, this.$data), state);\n      const changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue(position) {\n      const bounds = this.getValue();\n      const value = this.calcValueByPos(position);\n      const closestBound = this.getClosestBound(value);\n      const index = this.getBoundNeedMoving(value, closestBound);\n      const prevValue = bounds[index];\n      if (value === prevValue) return null;\n      const nextBounds = [...bounds];\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart(position) {\n      const {\n        bounds\n      } = this;\n      this.$emit('beforeChange', bounds);\n      const value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      const closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      const prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      const nextBounds = [...bounds];\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd(force) {\n      const {\n        sHandle\n      } = this;\n      this.removeDocumentEvents();\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      const {\n        $data: state,\n        $props: props\n      } = this;\n      const maxValue = props.max || 100;\n      const minValue = props.min || 0;\n      if (dragTrack) {\n        let pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        const max = maxValue - Math.max(...startBounds);\n        const min = minValue - Math.min(...startBounds);\n        const ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        const nextBounds = startBounds.map(v => Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue)));\n        if (state.bounds.map((c, i) => c === nextBounds[i]).some(c => !c)) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      const {\n        bounds,\n        sHandle\n      } = this;\n      const value = this.calcValueByPos(position);\n      const oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard(e) {\n      const {\n        reverse,\n        vertical\n      } = this.$props;\n      const valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        const {\n          bounds,\n          sHandle\n        } = this;\n        const oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        const mutatedValue = valueMutator(oldValue, this.$props);\n        const value = trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds,\n          props: this.$props\n        });\n        if (value === oldValue) return;\n        const isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound(value) {\n      const {\n        bounds\n      } = this;\n      let closestBound = 0;\n      for (let i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    },\n    getBoundNeedMoving(value, closestBound) {\n      const {\n        bounds,\n        recent\n      } = this;\n      let boundNeedMoving = closestBound;\n      const isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    },\n    getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound() {\n      const {\n        bounds\n      } = this;\n      return bounds[bounds.length - 1];\n    },\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints() {\n      const {\n        marks,\n        step,\n        min,\n        max\n      } = this;\n      const cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        const pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (let point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        const points = Object.keys(pointsObject).map(parseFloat);\n        points.sort((a, b) => a - b);\n        this.internalPointsCache = {\n          marks,\n          step,\n          points\n        };\n      }\n      return this.internalPointsCache.points;\n    },\n    moveTo(value, isFromKeyboardEvent) {\n      const nextBounds = [...this.bounds];\n      const {\n        sHandle,\n        recent\n      } = this;\n      const handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      let nextHandle = handle;\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort((a, b) => a - b);\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, () => {\n          this.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles(bounds, handle) {\n      const value = bounds[handle];\n      const {\n        pushable\n      } = this;\n      const threshold = Number(pushable);\n      let direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      const nextHandle = handle + direction;\n      const diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle(bounds, handle, direction, amount) {\n      const originalValue = bounds[handle];\n      let currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    },\n    pushHandleOnePoint(bounds, handle, direction) {\n      const points = this.getPoints();\n      const pointIndex = points.indexOf(bounds[handle]);\n      const nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      const nextHandle = handle + direction;\n      const nextValue = points[nextPointIndex];\n      const {\n        pushable\n      } = this;\n      const threshold = Number(pushable);\n      const diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue(value) {\n      const {\n        sHandle,\n        bounds\n      } = this;\n      return trimAlignValue({\n        value,\n        handle: sHandle,\n        bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict(handle, val, _ref2) {\n      let {\n        allowCross,\n        pushable: thershold\n      } = _ref2;\n      const state = this.$data || {};\n      const {\n        bounds\n      } = state;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    },\n    getTrack(_ref3) {\n      let {\n        bounds,\n        prefixCls,\n        reverse,\n        vertical,\n        included,\n        offsets,\n        trackStyle\n      } = _ref3;\n      return bounds.slice(0, -1).map((_, index) => {\n        const i = index + 1;\n        const trackClassName = classNames({\n          [`${prefixCls}-track`]: true,\n          [`${prefixCls}-track-${i}`]: true\n        });\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider() {\n      const {\n        sHandle,\n        bounds,\n        prefixCls,\n        vertical,\n        included,\n        disabled,\n        min,\n        max,\n        reverse,\n        handle,\n        defaultHandle,\n        trackStyle,\n        handleStyle,\n        tabindex,\n        ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles\n      } = this;\n      const handleGenerator = handle || defaultHandle;\n      const offsets = bounds.map(v => this.calcOffset(v));\n      const handleClassName = `${prefixCls}-handle`;\n      const handles = bounds.map((v, i) => {\n        let mergedTabIndex = tabindex[i] || 0;\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n        const dragging = sHandle === i;\n        return handleGenerator({\n          class: classNames({\n            [handleClassName]: true,\n            [`${handleClassName}-${i + 1}`]: true,\n            [`${handleClassName}-dragging`]: dragging\n          }),\n          prefixCls,\n          vertical,\n          dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min,\n          max,\n          reverse,\n          disabled,\n          style: handleStyle[i],\n          ref: h => this.saveHandle(i, h),\n          onFocus: this.onFocus,\n          onBlur: this.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds,\n          prefixCls,\n          reverse,\n          vertical,\n          included,\n          offsets,\n          trackStyle\n        }),\n        handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}