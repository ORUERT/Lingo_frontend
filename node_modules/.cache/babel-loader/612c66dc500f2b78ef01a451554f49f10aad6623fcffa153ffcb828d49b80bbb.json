{"ast":null,"code":"import _defineProperty from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _typeof from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport getMiniDecimal, { toFixed } from './utils/MiniDecimal';\nimport StepHandler from './StepHandler';\nimport { getNumberPrecision, num2str, validateNumber } from './utils/numberUtil';\nimport useCursor from './hooks/useCursor';\nimport useFrame from './hooks/useFrame';\nimport { watch, computed, shallowRef, defineComponent } from 'vue';\nimport KeyCode from '../../_util/KeyCode';\nimport classNames from '../../_util/classNames';\nimport { booleanType, stringType, someType, functionType } from '../../_util/type';\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nvar getDecimalValue = function getDecimalValue(stringMode, decimalValue) {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nvar getDecimalIfValidate = function getDecimalIfValidate(value) {\n  var decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nexport var inputNumberProps = function inputNumberProps() {\n  return {\n    /** value will show as string */\n    stringMode: booleanType(),\n    defaultValue: someType([String, Number]),\n    value: someType([String, Number]),\n    prefixCls: stringType(),\n    min: someType([String, Number]),\n    max: someType([String, Number]),\n    step: someType([String, Number], 1),\n    tabindex: Number,\n    controls: booleanType(true),\n    readonly: booleanType(),\n    disabled: booleanType(),\n    autofocus: booleanType(),\n    keyboard: booleanType(true),\n    /** Parse display value to validate number */\n    parser: functionType(),\n    /** Transform `value` to display value show in input */\n    formatter: functionType(),\n    /** Syntactic sugar of `formatter`. Config precision of display. */\n    precision: Number,\n    /** Syntactic sugar of `formatter`. Config decimal separator of display. */\n    decimalSeparator: String,\n    onInput: functionType(),\n    onChange: functionType(),\n    onPressEnter: functionType(),\n    onStep: functionType(),\n    onBlur: functionType(),\n    onFocus: functionType()\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'InnerInputNumber',\n  inheritAttrs: false,\n  props: _extends(_extends({}, inputNumberProps()), {\n    lazy: Boolean\n  }),\n  slots: Object,\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var inputRef = shallowRef();\n    var focus = shallowRef(false);\n    var userTypingRef = shallowRef(false);\n    var compositionRef = shallowRef(false);\n    var decimalValue = shallowRef(getMiniDecimal(props.value));\n    function setUncontrolledDecimalValue(newDecimal) {\n      if (props.value === undefined) {\n        decimalValue.value = newDecimal;\n      }\n    }\n    // ====================== Parser & Formatter ======================\n    /**\n     * `precision` is used for formatter & onChange.\n     * It will auto generate by `value` & `step`.\n     * But it will not block user typing.\n     *\n     * Note: Auto generate `precision` is used for legacy logic.\n     * We should remove this since we already support high precision with BigInt.\n     *\n     * @param number  Provide which number should calculate precision\n     * @param userTyping  Change by user typing\n     */\n    var getPrecision = function getPrecision(numStr, userTyping) {\n      if (userTyping) {\n        return undefined;\n      }\n      if (props.precision >= 0) {\n        return props.precision;\n      }\n      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props.step));\n    };\n    // >>> Parser\n    var mergedParser = function mergedParser(num) {\n      var numStr = String(num);\n      if (props.parser) {\n        return props.parser(numStr);\n      }\n      var parsedStr = numStr;\n      if (props.decimalSeparator) {\n        parsedStr = parsedStr.replace(props.decimalSeparator, '.');\n      }\n      // [Legacy] We still support auto convert `$ 123,456` to `123456`\n      return parsedStr.replace(/[^\\w.-]+/g, '');\n    };\n    // >>> Formatter\n    var inputValue = shallowRef('');\n    var mergedFormatter = function mergedFormatter(number, userTyping) {\n      if (props.formatter) {\n        return props.formatter(number, {\n          userTyping: userTyping,\n          input: String(inputValue.value)\n        });\n      }\n      var str = typeof number === 'number' ? num2str(number) : number;\n      // User typing will not auto format with precision directly\n      if (!userTyping) {\n        var mergedPrecision = getPrecision(str, userTyping);\n        if (validateNumber(str) && (props.decimalSeparator || mergedPrecision >= 0)) {\n          // Separator\n          var separatorStr = props.decimalSeparator || '.';\n          str = toFixed(str, separatorStr, mergedPrecision);\n        }\n      }\n      return str;\n    };\n    // ========================== InputValue ==========================\n    /**\n     * Input text value control\n     *\n     * User can not update input content directly. It update with follow rules by priority:\n     *  1. controlled `value` changed\n     *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n     *  2. User typing with format (not precision)\n     *  3. Blur or Enter trigger revalidate\n     */\n    var initValue = function () {\n      var initValue = props.value;\n      if (decimalValue.value.isInvalidate() && ['string', 'number'].includes(_typeof(initValue))) {\n        return Number.isNaN(initValue) ? '' : initValue;\n      }\n      return mergedFormatter(decimalValue.value.toString(), false);\n    }();\n    inputValue.value = initValue;\n    // Should always be string\n    function setInputValue(newValue, userTyping) {\n      inputValue.value = mergedFormatter(\n      // Invalidate number is sometime passed by external control, we should let it go\n      // Otherwise is controlled by internal interactive logic which check by userTyping\n      // You can ref 'show limited value when input is not focused' test for more info.\n      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);\n    }\n    // >>> Max & Min limit\n    var maxDecimal = computed(function () {\n      return getDecimalIfValidate(props.max);\n    });\n    var minDecimal = computed(function () {\n      return getDecimalIfValidate(props.min);\n    });\n    var upDisabled = computed(function () {\n      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return maxDecimal.value.lessEquals(decimalValue.value);\n    });\n    var downDisabled = computed(function () {\n      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return decimalValue.value.lessEquals(minDecimal.value);\n    });\n    // Cursor controller\n    var _useCursor = useCursor(inputRef, focus),\n      _useCursor2 = _slicedToArray(_useCursor, 2),\n      recordCursor = _useCursor2[0],\n      restoreCursor = _useCursor2[1];\n    // ============================= Data =============================\n    /**\n     * Find target value closet within range.\n     * e.g. [11, 28]:\n     *    3  => 11\n     *    23 => 23\n     *    99 => 28\n     */\n    var getRangeValue = function getRangeValue(target) {\n      // target > max\n      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {\n        return maxDecimal.value;\n      }\n      // target < min\n      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {\n        return minDecimal.value;\n      }\n      return null;\n    };\n    /**\n     * Check value is in [min, max] range\n     */\n    var isInRange = function isInRange(target) {\n      return !getRangeValue(target);\n    };\n    /**\n     * Trigger `onChange` if value validated and not equals of origin.\n     * Return the value that re-align in range.\n     */\n    var triggerValueUpdate = function triggerValueUpdate(newValue, userTyping) {\n      var _a;\n      var updateValue = newValue;\n      var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n      // Skip align value when trigger value is empty.\n      // We just trigger onChange(null)\n      // This should not block user typing\n      if (!updateValue.isEmpty() && !userTyping) {\n        // Revert value in range if needed\n        updateValue = getRangeValue(updateValue) || updateValue;\n        isRangeValidate = true;\n      }\n      if (!props.readonly && !props.disabled && isRangeValidate) {\n        var numStr = updateValue.toString();\n        var mergedPrecision = getPrecision(numStr, userTyping);\n        if (mergedPrecision >= 0) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n        }\n        // Trigger event\n        if (!updateValue.equals(decimalValue.value)) {\n          setUncontrolledDecimalValue(updateValue);\n          (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, updateValue.isEmpty() ? null : getDecimalValue(props.stringMode, updateValue));\n          // Reformat input if value is not controlled\n          if (props.value === undefined) {\n            setInputValue(updateValue, userTyping);\n          }\n        }\n        return updateValue;\n      }\n      return decimalValue.value;\n    };\n    // ========================== User Input ==========================\n    var onNextPromise = useFrame();\n    // >>> Collect input value\n    var collectInputValue = function collectInputValue(inputStr) {\n      var _a;\n      recordCursor();\n      // Update inputValue incase input can not parse as number\n      inputValue.value = inputStr;\n      // Parse number\n      if (!compositionRef.value) {\n        var finalValue = mergedParser(inputStr);\n        var finalDecimal = getMiniDecimal(finalValue);\n        if (!finalDecimal.isNaN()) {\n          triggerValueUpdate(finalDecimal, true);\n        }\n      }\n      // Trigger onInput later to let user customize value if they want do handle something after onChange\n      (_a = props.onInput) === null || _a === void 0 ? void 0 : _a.call(props, inputStr);\n      // optimize for chinese input experience\n      // https://github.com/ant-design/ant-design/issues/8196\n      onNextPromise(function () {\n        var nextInputStr = inputStr;\n        if (!props.parser) {\n          nextInputStr = inputStr.replace(/。/g, '.');\n        }\n        if (nextInputStr !== inputStr) {\n          collectInputValue(nextInputStr);\n        }\n      });\n    };\n    // >>> Composition\n    var onCompositionStart = function onCompositionStart() {\n      compositionRef.value = true;\n    };\n    var onCompositionEnd = function onCompositionEnd() {\n      compositionRef.value = false;\n      collectInputValue(inputRef.value.value);\n    };\n    // >>> Input\n    var onInternalInput = function onInternalInput(e) {\n      collectInputValue(e.target.value);\n    };\n    // ============================= Step =============================\n    var onInternalStep = function onInternalStep(up) {\n      var _a, _b;\n      // Ignore step since out of range\n      if (up && upDisabled.value || !up && downDisabled.value) {\n        return;\n      }\n      // Clear typing status since it may caused by up & down key.\n      // We should sync with input value.\n      userTypingRef.value = false;\n      var stepDecimal = getMiniDecimal(props.step);\n      if (!up) {\n        stepDecimal = stepDecimal.negate();\n      }\n      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());\n      var updatedValue = triggerValueUpdate(target, false);\n      (_a = props.onStep) === null || _a === void 0 ? void 0 : _a.call(props, getDecimalValue(props.stringMode, updatedValue), {\n        offset: props.step,\n        type: up ? 'up' : 'down'\n      });\n      (_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.focus();\n    };\n    // ============================ Flush =============================\n    /**\n     * Flush current input content to trigger value change & re-formatter input if needed\n     */\n    var flushInputValue = function flushInputValue(userTyping) {\n      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      var formatValue = parsedValue;\n      if (!parsedValue.isNaN()) {\n        // Only validate value or empty value can be re-fill to inputValue\n        // Reassign the formatValue within ranged of trigger control\n        formatValue = triggerValueUpdate(parsedValue, userTyping);\n      } else {\n        formatValue = decimalValue.value;\n      }\n      if (props.value !== undefined) {\n        // Reset back with controlled value first\n        setInputValue(decimalValue.value, false);\n      } else if (!formatValue.isNaN()) {\n        // Reset input back since no validate value\n        setInputValue(formatValue, false);\n      }\n    };\n    var onKeyDown = function onKeyDown(event) {\n      var _a;\n      var which = event.which;\n      userTypingRef.value = true;\n      if (which === KeyCode.ENTER) {\n        if (!compositionRef.value) {\n          userTypingRef.value = false;\n        }\n        flushInputValue(false);\n        (_a = props.onPressEnter) === null || _a === void 0 ? void 0 : _a.call(props, event);\n      }\n      if (props.keyboard === false) {\n        return;\n      }\n      // Do step\n      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {\n        onInternalStep(KeyCode.UP === which);\n        event.preventDefault();\n      }\n    };\n    var onKeyUp = function onKeyUp() {\n      userTypingRef.value = false;\n    };\n    // >>> Focus & Blur\n    var onBlur = function onBlur(e) {\n      flushInputValue(false);\n      focus.value = false;\n      userTypingRef.value = false;\n      emit('blur', e);\n    };\n    // ========================== Controlled ==========================\n    // Input by precision\n    watch(function () {\n      return props.precision;\n    }, function () {\n      if (!decimalValue.value.isInvalidate()) {\n        setInputValue(decimalValue.value, false);\n      }\n    }, {\n      flush: 'post'\n    });\n    // Input by value\n    watch(function () {\n      return props.value;\n    }, function () {\n      var newValue = getMiniDecimal(props.value);\n      decimalValue.value = newValue;\n      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n      // But let it go if user set `formatter`\n      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props.formatter) {\n        // Update value as effect\n        setInputValue(newValue, userTypingRef.value);\n      }\n    }, {\n      flush: 'post'\n    });\n    // ============================ Cursor ============================\n    watch(inputValue, function () {\n      if (props.formatter) {\n        restoreCursor();\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(function () {\n      return props.disabled;\n    }, function (val) {\n      if (val) {\n        focus.value = false;\n      }\n    });\n    expose({\n      focus: function focus() {\n        var _a;\n        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();\n      },\n      blur: function blur() {\n        var _a;\n        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    });\n    return function () {\n      var _classNames;\n      var _a = _extends(_extends({}, attrs), props),\n        _a$prefixCls = _a.prefixCls,\n        prefixCls = _a$prefixCls === void 0 ? 'rc-input-number' : _a$prefixCls,\n        min = _a.min,\n        max = _a.max,\n        _a$step = _a.step,\n        step = _a$step === void 0 ? 1 : _a$step,\n        defaultValue = _a.defaultValue,\n        value = _a.value,\n        disabled = _a.disabled,\n        readonly = _a.readonly,\n        keyboard = _a.keyboard,\n        _a$controls = _a.controls,\n        controls = _a$controls === void 0 ? true : _a$controls,\n        autofocus = _a.autofocus,\n        stringMode = _a.stringMode,\n        parser = _a.parser,\n        formatter = _a.formatter,\n        precision = _a.precision,\n        decimalSeparator = _a.decimalSeparator,\n        onChange = _a.onChange,\n        onInput = _a.onInput,\n        onPressEnter = _a.onPressEnter,\n        onStep = _a.onStep,\n        lazy = _a.lazy,\n        className = _a[\"class\"],\n        style = _a.style,\n        inputProps = __rest(_a, [\"prefixCls\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readonly\", \"keyboard\", \"controls\", \"autofocus\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"lazy\", \"class\", \"style\"]);\n      var upHandler = slots.upHandler,\n        downHandler = slots.downHandler;\n      var inputClassName = \"\".concat(prefixCls, \"-input\");\n      var eventProps = {};\n      if (lazy) {\n        eventProps.onChange = onInternalInput;\n      } else {\n        eventProps.onInput = onInternalInput;\n      }\n      return _createVNode(\"div\", {\n        \"class\": classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-focused\"), focus.value), _defineProperty(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefixCls, \"-readonly\"), readonly), _defineProperty(_classNames, \"\".concat(prefixCls, \"-not-a-number\"), decimalValue.value.isNaN()), _defineProperty(_classNames, \"\".concat(prefixCls, \"-out-of-range\"), !decimalValue.value.isInvalidate() && !isInRange(decimalValue.value)), _classNames)),\n        \"style\": style,\n        \"onKeydown\": onKeyDown,\n        \"onKeyup\": onKeyUp\n      }, [controls && _createVNode(StepHandler, {\n        \"prefixCls\": prefixCls,\n        \"upDisabled\": upDisabled.value,\n        \"downDisabled\": downDisabled.value,\n        \"onStep\": onInternalStep\n      }, {\n        upNode: upHandler,\n        downNode: downHandler\n      }), _createVNode(\"div\", {\n        \"class\": \"\".concat(inputClassName, \"-wrap\")\n      }, [_createVNode(\"input\", _objectSpread(_objectSpread(_objectSpread({\n        \"autofocus\": autofocus,\n        \"autocomplete\": \"off\",\n        \"role\": \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),\n        \"step\": step\n      }, inputProps), {}, {\n        \"ref\": inputRef,\n        \"class\": inputClassName,\n        \"value\": inputValue.value,\n        \"disabled\": disabled,\n        \"readonly\": readonly,\n        \"onFocus\": function onFocus(e) {\n          focus.value = true;\n          emit('focus', e);\n        }\n      }, eventProps), {}, {\n        \"onBlur\": onBlur,\n        \"onCompositionstart\": onCompositionStart,\n        \"onCompositionend\": onCompositionEnd\n      }), null)])]);\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","resolveDirective","_resolveDirective","__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","getMiniDecimal","toFixed","StepHandler","getNumberPrecision","num2str","validateNumber","useCursor","useFrame","watch","computed","shallowRef","defineComponent","KeyCode","classNames","booleanType","stringType","someType","functionType","getDecimalValue","stringMode","decimalValue","isEmpty","toString","toNumber","getDecimalIfValidate","value","decimal","isInvalidate","inputNumberProps","defaultValue","String","Number","prefixCls","min","max","step","tabindex","controls","readonly","disabled","autofocus","keyboard","parser","formatter","precision","decimalSeparator","onInput","onChange","onPressEnter","onStep","onBlur","onFocus","compatConfig","MODE","name","inheritAttrs","props","lazy","Boolean","slots","setup","_ref","attrs","emit","expose","inputRef","focus","userTypingRef","compositionRef","setUncontrolledDecimalValue","newDecimal","undefined","getPrecision","numStr","userTyping","Math","mergedParser","num","parsedStr","replace","inputValue","mergedFormatter","number","input","str","mergedPrecision","separatorStr","initValue","includes","_typeof","isNaN","setInputValue","newValue","maxDecimal","minDecimal","upDisabled","lessEquals","downDisabled","_useCursor","_useCursor2","_slicedToArray","recordCursor","restoreCursor","getRangeValue","target","isInRange","triggerValueUpdate","_a","updateValue","isRangeValidate","equals","onNextPromise","collectInputValue","inputStr","finalValue","finalDecimal","nextInputStr","onCompositionStart","onCompositionEnd","onInternalInput","onInternalStep","up","_b","stepDecimal","negate","add","updatedValue","offset","type","flushInputValue","parsedValue","formatValue","onKeyDown","event","which","ENTER","UP","DOWN","preventDefault","onKeyUp","flush","currentParsedValue","val","blur","_classNames","_a$prefixCls","_a$step","_a$controls","className","style","inputProps","upHandler","downHandler","inputClassName","concat","eventProps","_defineProperty","upNode","downNode"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/input-number/src/InputNumber.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport getMiniDecimal, { toFixed } from './utils/MiniDecimal';\nimport StepHandler from './StepHandler';\nimport { getNumberPrecision, num2str, validateNumber } from './utils/numberUtil';\nimport useCursor from './hooks/useCursor';\nimport useFrame from './hooks/useFrame';\nimport { watch, computed, shallowRef, defineComponent } from 'vue';\nimport KeyCode from '../../_util/KeyCode';\nimport classNames from '../../_util/classNames';\nimport { booleanType, stringType, someType, functionType } from '../../_util/type';\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nconst getDecimalValue = (stringMode, decimalValue) => {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nconst getDecimalIfValidate = value => {\n  const decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nexport const inputNumberProps = () => ({\n  /** value will show as string */\n  stringMode: booleanType(),\n  defaultValue: someType([String, Number]),\n  value: someType([String, Number]),\n  prefixCls: stringType(),\n  min: someType([String, Number]),\n  max: someType([String, Number]),\n  step: someType([String, Number], 1),\n  tabindex: Number,\n  controls: booleanType(true),\n  readonly: booleanType(),\n  disabled: booleanType(),\n  autofocus: booleanType(),\n  keyboard: booleanType(true),\n  /** Parse display value to validate number */\n  parser: functionType(),\n  /** Transform `value` to display value show in input */\n  formatter: functionType(),\n  /** Syntactic sugar of `formatter`. Config precision of display. */\n  precision: Number,\n  /** Syntactic sugar of `formatter`. Config decimal separator of display. */\n  decimalSeparator: String,\n  onInput: functionType(),\n  onChange: functionType(),\n  onPressEnter: functionType(),\n  onStep: functionType(),\n  onBlur: functionType(),\n  onFocus: functionType()\n});\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'InnerInputNumber',\n  inheritAttrs: false,\n  props: _extends(_extends({}, inputNumberProps()), {\n    lazy: Boolean\n  }),\n  slots: Object,\n  setup(props, _ref) {\n    let {\n      attrs,\n      slots,\n      emit,\n      expose\n    } = _ref;\n    const inputRef = shallowRef();\n    const focus = shallowRef(false);\n    const userTypingRef = shallowRef(false);\n    const compositionRef = shallowRef(false);\n    const decimalValue = shallowRef(getMiniDecimal(props.value));\n    function setUncontrolledDecimalValue(newDecimal) {\n      if (props.value === undefined) {\n        decimalValue.value = newDecimal;\n      }\n    }\n    // ====================== Parser & Formatter ======================\n    /**\n     * `precision` is used for formatter & onChange.\n     * It will auto generate by `value` & `step`.\n     * But it will not block user typing.\n     *\n     * Note: Auto generate `precision` is used for legacy logic.\n     * We should remove this since we already support high precision with BigInt.\n     *\n     * @param number  Provide which number should calculate precision\n     * @param userTyping  Change by user typing\n     */\n    const getPrecision = (numStr, userTyping) => {\n      if (userTyping) {\n        return undefined;\n      }\n      if (props.precision >= 0) {\n        return props.precision;\n      }\n      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props.step));\n    };\n    // >>> Parser\n    const mergedParser = num => {\n      const numStr = String(num);\n      if (props.parser) {\n        return props.parser(numStr);\n      }\n      let parsedStr = numStr;\n      if (props.decimalSeparator) {\n        parsedStr = parsedStr.replace(props.decimalSeparator, '.');\n      }\n      // [Legacy] We still support auto convert `$ 123,456` to `123456`\n      return parsedStr.replace(/[^\\w.-]+/g, '');\n    };\n    // >>> Formatter\n    const inputValue = shallowRef('');\n    const mergedFormatter = (number, userTyping) => {\n      if (props.formatter) {\n        return props.formatter(number, {\n          userTyping,\n          input: String(inputValue.value)\n        });\n      }\n      let str = typeof number === 'number' ? num2str(number) : number;\n      // User typing will not auto format with precision directly\n      if (!userTyping) {\n        const mergedPrecision = getPrecision(str, userTyping);\n        if (validateNumber(str) && (props.decimalSeparator || mergedPrecision >= 0)) {\n          // Separator\n          const separatorStr = props.decimalSeparator || '.';\n          str = toFixed(str, separatorStr, mergedPrecision);\n        }\n      }\n      return str;\n    };\n    // ========================== InputValue ==========================\n    /**\n     * Input text value control\n     *\n     * User can not update input content directly. It update with follow rules by priority:\n     *  1. controlled `value` changed\n     *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n     *  2. User typing with format (not precision)\n     *  3. Blur or Enter trigger revalidate\n     */\n    const initValue = (() => {\n      const initValue = props.value;\n      if (decimalValue.value.isInvalidate() && ['string', 'number'].includes(typeof initValue)) {\n        return Number.isNaN(initValue) ? '' : initValue;\n      }\n      return mergedFormatter(decimalValue.value.toString(), false);\n    })();\n    inputValue.value = initValue;\n    // Should always be string\n    function setInputValue(newValue, userTyping) {\n      inputValue.value = mergedFormatter(\n      // Invalidate number is sometime passed by external control, we should let it go\n      // Otherwise is controlled by internal interactive logic which check by userTyping\n      // You can ref 'show limited value when input is not focused' test for more info.\n      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);\n    }\n    // >>> Max & Min limit\n    const maxDecimal = computed(() => getDecimalIfValidate(props.max));\n    const minDecimal = computed(() => getDecimalIfValidate(props.min));\n    const upDisabled = computed(() => {\n      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return maxDecimal.value.lessEquals(decimalValue.value);\n    });\n    const downDisabled = computed(() => {\n      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return decimalValue.value.lessEquals(minDecimal.value);\n    });\n    // Cursor controller\n    const [recordCursor, restoreCursor] = useCursor(inputRef, focus);\n    // ============================= Data =============================\n    /**\n     * Find target value closet within range.\n     * e.g. [11, 28]:\n     *    3  => 11\n     *    23 => 23\n     *    99 => 28\n     */\n    const getRangeValue = target => {\n      // target > max\n      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {\n        return maxDecimal.value;\n      }\n      // target < min\n      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {\n        return minDecimal.value;\n      }\n      return null;\n    };\n    /**\n     * Check value is in [min, max] range\n     */\n    const isInRange = target => !getRangeValue(target);\n    /**\n     * Trigger `onChange` if value validated and not equals of origin.\n     * Return the value that re-align in range.\n     */\n    const triggerValueUpdate = (newValue, userTyping) => {\n      var _a;\n      let updateValue = newValue;\n      let isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n      // Skip align value when trigger value is empty.\n      // We just trigger onChange(null)\n      // This should not block user typing\n      if (!updateValue.isEmpty() && !userTyping) {\n        // Revert value in range if needed\n        updateValue = getRangeValue(updateValue) || updateValue;\n        isRangeValidate = true;\n      }\n      if (!props.readonly && !props.disabled && isRangeValidate) {\n        const numStr = updateValue.toString();\n        const mergedPrecision = getPrecision(numStr, userTyping);\n        if (mergedPrecision >= 0) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n        }\n        // Trigger event\n        if (!updateValue.equals(decimalValue.value)) {\n          setUncontrolledDecimalValue(updateValue);\n          (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, updateValue.isEmpty() ? null : getDecimalValue(props.stringMode, updateValue));\n          // Reformat input if value is not controlled\n          if (props.value === undefined) {\n            setInputValue(updateValue, userTyping);\n          }\n        }\n        return updateValue;\n      }\n      return decimalValue.value;\n    };\n    // ========================== User Input ==========================\n    const onNextPromise = useFrame();\n    // >>> Collect input value\n    const collectInputValue = inputStr => {\n      var _a;\n      recordCursor();\n      // Update inputValue incase input can not parse as number\n      inputValue.value = inputStr;\n      // Parse number\n      if (!compositionRef.value) {\n        const finalValue = mergedParser(inputStr);\n        const finalDecimal = getMiniDecimal(finalValue);\n        if (!finalDecimal.isNaN()) {\n          triggerValueUpdate(finalDecimal, true);\n        }\n      }\n      // Trigger onInput later to let user customize value if they want do handle something after onChange\n      (_a = props.onInput) === null || _a === void 0 ? void 0 : _a.call(props, inputStr);\n      // optimize for chinese input experience\n      // https://github.com/ant-design/ant-design/issues/8196\n      onNextPromise(() => {\n        let nextInputStr = inputStr;\n        if (!props.parser) {\n          nextInputStr = inputStr.replace(/。/g, '.');\n        }\n        if (nextInputStr !== inputStr) {\n          collectInputValue(nextInputStr);\n        }\n      });\n    };\n    // >>> Composition\n    const onCompositionStart = () => {\n      compositionRef.value = true;\n    };\n    const onCompositionEnd = () => {\n      compositionRef.value = false;\n      collectInputValue(inputRef.value.value);\n    };\n    // >>> Input\n    const onInternalInput = e => {\n      collectInputValue(e.target.value);\n    };\n    // ============================= Step =============================\n    const onInternalStep = up => {\n      var _a, _b;\n      // Ignore step since out of range\n      if (up && upDisabled.value || !up && downDisabled.value) {\n        return;\n      }\n      // Clear typing status since it may caused by up & down key.\n      // We should sync with input value.\n      userTypingRef.value = false;\n      let stepDecimal = getMiniDecimal(props.step);\n      if (!up) {\n        stepDecimal = stepDecimal.negate();\n      }\n      const target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());\n      const updatedValue = triggerValueUpdate(target, false);\n      (_a = props.onStep) === null || _a === void 0 ? void 0 : _a.call(props, getDecimalValue(props.stringMode, updatedValue), {\n        offset: props.step,\n        type: up ? 'up' : 'down'\n      });\n      (_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.focus();\n    };\n    // ============================ Flush =============================\n    /**\n     * Flush current input content to trigger value change & re-formatter input if needed\n     */\n    const flushInputValue = userTyping => {\n      const parsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      let formatValue = parsedValue;\n      if (!parsedValue.isNaN()) {\n        // Only validate value or empty value can be re-fill to inputValue\n        // Reassign the formatValue within ranged of trigger control\n        formatValue = triggerValueUpdate(parsedValue, userTyping);\n      } else {\n        formatValue = decimalValue.value;\n      }\n      if (props.value !== undefined) {\n        // Reset back with controlled value first\n        setInputValue(decimalValue.value, false);\n      } else if (!formatValue.isNaN()) {\n        // Reset input back since no validate value\n        setInputValue(formatValue, false);\n      }\n    };\n    const onKeyDown = event => {\n      var _a;\n      const {\n        which\n      } = event;\n      userTypingRef.value = true;\n      if (which === KeyCode.ENTER) {\n        if (!compositionRef.value) {\n          userTypingRef.value = false;\n        }\n        flushInputValue(false);\n        (_a = props.onPressEnter) === null || _a === void 0 ? void 0 : _a.call(props, event);\n      }\n      if (props.keyboard === false) {\n        return;\n      }\n      // Do step\n      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {\n        onInternalStep(KeyCode.UP === which);\n        event.preventDefault();\n      }\n    };\n    const onKeyUp = () => {\n      userTypingRef.value = false;\n    };\n    // >>> Focus & Blur\n    const onBlur = e => {\n      flushInputValue(false);\n      focus.value = false;\n      userTypingRef.value = false;\n      emit('blur', e);\n    };\n    // ========================== Controlled ==========================\n    // Input by precision\n    watch(() => props.precision, () => {\n      if (!decimalValue.value.isInvalidate()) {\n        setInputValue(decimalValue.value, false);\n      }\n    }, {\n      flush: 'post'\n    });\n    // Input by value\n    watch(() => props.value, () => {\n      const newValue = getMiniDecimal(props.value);\n      decimalValue.value = newValue;\n      const currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n      // But let it go if user set `formatter`\n      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props.formatter) {\n        // Update value as effect\n        setInputValue(newValue, userTypingRef.value);\n      }\n    }, {\n      flush: 'post'\n    });\n    // ============================ Cursor ============================\n    watch(inputValue, () => {\n      if (props.formatter) {\n        restoreCursor();\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(() => props.disabled, val => {\n      if (val) {\n        focus.value = false;\n      }\n    });\n    expose({\n      focus: () => {\n        var _a;\n        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();\n      },\n      blur: () => {\n        var _a;\n        (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    });\n    return () => {\n      const _a = _extends(_extends({}, attrs), props),\n        {\n          prefixCls = 'rc-input-number',\n          min,\n          max,\n          step = 1,\n          defaultValue,\n          value,\n          disabled,\n          readonly,\n          keyboard,\n          controls = true,\n          autofocus,\n          stringMode,\n          parser,\n          formatter,\n          precision,\n          decimalSeparator,\n          onChange,\n          onInput,\n          onPressEnter,\n          onStep,\n          lazy,\n          class: className,\n          style\n        } = _a,\n        inputProps = __rest(_a, [\"prefixCls\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readonly\", \"keyboard\", \"controls\", \"autofocus\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"lazy\", \"class\", \"style\"]);\n      const {\n        upHandler,\n        downHandler\n      } = slots;\n      const inputClassName = `${prefixCls}-input`;\n      const eventProps = {};\n      if (lazy) {\n        eventProps.onChange = onInternalInput;\n      } else {\n        eventProps.onInput = onInternalInput;\n      }\n      return _createVNode(\"div\", {\n        \"class\": classNames(prefixCls, className, {\n          [`${prefixCls}-focused`]: focus.value,\n          [`${prefixCls}-disabled`]: disabled,\n          [`${prefixCls}-readonly`]: readonly,\n          [`${prefixCls}-not-a-number`]: decimalValue.value.isNaN(),\n          [`${prefixCls}-out-of-range`]: !decimalValue.value.isInvalidate() && !isInRange(decimalValue.value)\n        }),\n        \"style\": style,\n        \"onKeydown\": onKeyDown,\n        \"onKeyup\": onKeyUp\n      }, [controls && _createVNode(StepHandler, {\n        \"prefixCls\": prefixCls,\n        \"upDisabled\": upDisabled.value,\n        \"downDisabled\": downDisabled.value,\n        \"onStep\": onInternalStep\n      }, {\n        upNode: upHandler,\n        downNode: downHandler\n      }), _createVNode(\"div\", {\n        \"class\": `${inputClassName}-wrap`\n      }, [_createVNode(\"input\", _objectSpread(_objectSpread(_objectSpread({\n        \"autofocus\": autofocus,\n        \"autocomplete\": \"off\",\n        \"role\": \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),\n        \"step\": step\n      }, inputProps), {}, {\n        \"ref\": inputRef,\n        \"class\": inputClassName,\n        \"value\": inputValue.value,\n        \"disabled\": disabled,\n        \"readonly\": readonly,\n        \"onFocus\": e => {\n          focus.value = true;\n          emit('focus', e);\n        }\n      }, eventProps), {}, {\n        \"onBlur\": onBlur,\n        \"onCompositionstart\": onCompositionStart,\n        \"onCompositionend\": onCompositionEnd\n      }), null)])]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}