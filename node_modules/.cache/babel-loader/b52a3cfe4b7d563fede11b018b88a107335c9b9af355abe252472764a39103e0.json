{"ast":null,"code":"import _slicedToArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _typeof from \"C:/Users/zhouy/WebstormProjects/lingo/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport hash from '@emotion/hash';\n// @ts-ignore\nimport unitless from '@emotion/unitless';\nimport { compile, serialize, stringify } from 'stylis';\nimport { contentQuotesLinter, hashedAnimationLinter } from '../linters';\nimport { useStyleInject, ATTR_DEV_CACHE_PATH, ATTR_MARK, ATTR_TOKEN, CSS_IN_JS_INSTANCE, CSS_IN_JS_INSTANCE_ID } from '../StyleContext';\nimport { supportLayer } from '../util';\nimport useGlobalCache from './useGlobalCache';\nimport canUseDom from '../../canUseDom';\nimport { removeCSS, updateCSS } from '../../../vc-util/Dom/dynamicCSS';\nimport { computed } from 'vue';\nvar isClientSide = canUseDom();\nvar SKIP_CHECK = '_skip_check_';\n// ============================================================================\n// ==                                 Parser                                 ==\n// ============================================================================\n// Preprocessor style content to browser support one\nexport function normalizeStyle(styleStr) {\n  var serialized = serialize(compile(styleStr), stringify);\n  return serialized.replace(/\\{%%%\\:[^;];}/g, ';');\n}\nfunction isCompoundCSSProperty(value) {\n  return _typeof(value) === 'object' && value && SKIP_CHECK in value;\n}\n// 注入 hash 值\nfunction injectSelectorHash(key, hashId, hashPriority) {\n  if (!hashId) {\n    return key;\n  }\n  var hashClassName = \".\".concat(hashId);\n  var hashSelector = hashPriority === 'low' ? \":where(\".concat(hashClassName, \")\") : hashClassName;\n  // 注入 hashId\n  var keys = key.split(',').map(function (k) {\n    var _a;\n    var fullPath = k.trim().split(/\\s+/);\n    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。\n    var firstPath = fullPath[0] || '';\n    var htmlElement = ((_a = firstPath.match(/^\\w+/)) === null || _a === void 0 ? void 0 : _a[0]) || '';\n    firstPath = \"\".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));\n    return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(' ');\n  });\n  return keys.join(',');\n}\n// Global effect style will mount once and not removed\n// The effect will not save in SSR cache (e.g. keyframes)\nvar globalEffectStyleKeys = new Set();\n/**\n * @private Test only. Clear the global effect style keys.\n */\nexport var _cf = process.env.NODE_ENV !== 'production' ? function () {\n  return globalEffectStyleKeys.clear();\n} : undefined;\n// Parse CSSObject to style content\nexport var parseStyle = function parseStyle(interpolation) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      root: true,\n      parentSelectors: []\n    },\n    root = _ref2.root,\n    injectHash = _ref2.injectHash,\n    parentSelectors = _ref2.parentSelectors;\n  var hashId = config.hashId,\n    layer = config.layer,\n    path = config.path,\n    hashPriority = config.hashPriority,\n    _config$transformers = config.transformers,\n    transformers = _config$transformers === void 0 ? [] : _config$transformers,\n    _config$linters = config.linters,\n    linters = _config$linters === void 0 ? [] : _config$linters;\n  var styleStr = '';\n  var effectStyle = {};\n  function parseKeyframes(keyframes) {\n    var animationName = keyframes.getName(hashId);\n    if (!effectStyle[animationName]) {\n      var _parseStyle = parseStyle(keyframes.style, config, {\n          root: false,\n          parentSelectors: parentSelectors\n        }),\n        _parseStyle2 = _slicedToArray(_parseStyle, 1),\n        parsedStr = _parseStyle2[0];\n      effectStyle[animationName] = \"@keyframes \".concat(keyframes.getName(hashId)).concat(parsedStr);\n    }\n  }\n  function flattenList(list) {\n    var fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    list.forEach(function (item) {\n      if (Array.isArray(item)) {\n        flattenList(item, fullList);\n      } else if (item) {\n        fullList.push(item);\n      }\n    });\n    return fullList;\n  }\n  var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);\n  flattenStyleList.forEach(function (originStyle) {\n    // Only root level can use raw string\n    var style = typeof originStyle === 'string' && !root ? {} : originStyle;\n    if (typeof style === 'string') {\n      styleStr += \"\".concat(style, \"\\n\");\n    } else if (style._keyframe) {\n      // Keyframe\n      parseKeyframes(style);\n    } else {\n      var mergedStyle = transformers.reduce(function (prev, trans) {\n        var _a;\n        return ((_a = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a === void 0 ? void 0 : _a.call(trans, prev)) || prev;\n      }, style);\n      // Normal CSSObject\n      Object.keys(mergedStyle).forEach(function (key) {\n        var _a;\n        var value = mergedStyle[key];\n        if (_typeof(value) === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {\n          var subInjectHash = false;\n          // 当成嵌套对象来处理\n          var mergedKey = key.trim();\n          // Whether treat child as root. In most case it is false.\n          var nextRoot = false;\n          // 拆分多个选择器\n          if ((root || injectHash) && hashId) {\n            if (mergedKey.startsWith('@')) {\n              // 略过媒体查询，交给子节点继续插入 hashId\n              subInjectHash = true;\n            } else {\n              // 注入 hashId\n              mergedKey = injectSelectorHash(key, hashId, hashPriority);\n            }\n          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {\n            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,\n            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.\n            // But it does not conform to stylis syntax,\n            // and finally we will get `{color:red;}` as css, which is wrong.\n            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.\n            mergedKey = '';\n            nextRoot = true;\n          }\n          var _parseStyle3 = parseStyle(value, config, {\n              root: nextRoot,\n              injectHash: subInjectHash,\n              parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])\n            }),\n            _parseStyle4 = _slicedToArray(_parseStyle3, 2),\n            parsedStr = _parseStyle4[0],\n            childEffectStyle = _parseStyle4[1];\n          effectStyle = _extends(_extends({}, effectStyle), childEffectStyle);\n          styleStr += \"\".concat(mergedKey).concat(parsedStr);\n        } else {\n          var actualValue = (_a = value === null || value === void 0 ? void 0 : value.value) !== null && _a !== void 0 ? _a : value;\n          if (process.env.NODE_ENV !== 'production' && (_typeof(value) !== 'object' || !(value === null || value === void 0 ? void 0 : value[SKIP_CHECK]))) {\n            [contentQuotesLinter, hashedAnimationLinter].concat(_toConsumableArray(linters)).forEach(function (linter) {\n              return linter(key, actualValue, {\n                path: path,\n                hashId: hashId,\n                parentSelectors: parentSelectors\n              });\n            });\n          }\n          // 如果是样式则直接插入\n          var styleName = key.replace(/[A-Z]/g, function (match) {\n            return \"-\".concat(match.toLowerCase());\n          });\n          // Auto suffix with px\n          var formatValue = actualValue;\n          if (!unitless[key] && typeof formatValue === 'number' && formatValue !== 0) {\n            formatValue = \"\".concat(formatValue, \"px\");\n          }\n          // handle animationName & Keyframe value\n          if (key === 'animationName' && (value === null || value === void 0 ? void 0 : value._keyframe)) {\n            parseKeyframes(value);\n            formatValue = value.getName(hashId);\n          }\n          styleStr += \"\".concat(styleName, \":\").concat(formatValue, \";\");\n        }\n      });\n    }\n  });\n  if (!root) {\n    styleStr = \"{\".concat(styleStr, \"}\");\n  } else if (layer && supportLayer()) {\n    var layerCells = layer.split(',');\n    var layerName = layerCells[layerCells.length - 1].trim();\n    styleStr = \"@layer \".concat(layerName, \" {\").concat(styleStr, \"}\");\n    // Order of layer if needed\n    if (layerCells.length > 1) {\n      // zombieJ: stylis do not support layer order, so we need to handle it manually.\n      styleStr = \"@layer \".concat(layer, \"{%%%:%}\").concat(styleStr);\n    }\n  }\n  return [styleStr, effectStyle];\n};\n// ============================================================================\n// ==                                Register                                ==\n// ============================================================================\nfunction uniqueHash(path, styleStr) {\n  return hash(\"\".concat(path.join('%')).concat(styleStr));\n}\n// function Empty() {\n//   return null;\n// }\n/**\n * Register a style to the global style sheet.\n */\nexport default function useStyleRegister(info, styleFn) {\n  var styleContext = useStyleInject();\n  var tokenKey = computed(function () {\n    return info.value.token._tokenKey;\n  });\n  var fullPath = computed(function () {\n    return [tokenKey.value].concat(_toConsumableArray(info.value.path));\n  });\n  // Check if need insert style\n  var isMergedClientSide = isClientSide;\n  if (process.env.NODE_ENV !== 'production' && styleContext.value.mock !== undefined) {\n    isMergedClientSide = styleContext.value.mock === 'client';\n  }\n  // const [cacheStyle[0], cacheStyle[1], cacheStyle[2]]\n  useGlobalCache('style', fullPath,\n  // Create cache if needed\n  function () {\n    var styleObj = styleFn();\n    var _styleContext$value = styleContext.value,\n      hashPriority = _styleContext$value.hashPriority,\n      container = _styleContext$value.container,\n      transformers = _styleContext$value.transformers,\n      linters = _styleContext$value.linters;\n    var _info$value = info.value,\n      path = _info$value.path,\n      hashId = _info$value.hashId,\n      layer = _info$value.layer;\n    var _parseStyle5 = parseStyle(styleObj, {\n        hashId: hashId,\n        hashPriority: hashPriority,\n        layer: layer,\n        path: path.join('-'),\n        transformers: transformers,\n        linters: linters\n      }),\n      _parseStyle6 = _slicedToArray(_parseStyle5, 2),\n      parsedStyle = _parseStyle6[0],\n      effectStyle = _parseStyle6[1];\n    var styleStr = normalizeStyle(parsedStyle);\n    var styleId = uniqueHash(fullPath.value, styleStr);\n    if (isMergedClientSide) {\n      var style = updateCSS(styleStr, styleId, {\n        mark: ATTR_MARK,\n        prepend: 'queue',\n        attachTo: container\n      });\n      style[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;\n      // Used for `useCacheToken` to remove on batch when token removed\n      style.setAttribute(ATTR_TOKEN, tokenKey.value);\n      // Dev usage to find which cache path made this easily\n      if (process.env.NODE_ENV !== 'production') {\n        style.setAttribute(ATTR_DEV_CACHE_PATH, fullPath.value.join('|'));\n      }\n      // Inject client side effect style\n      Object.keys(effectStyle).forEach(function (effectKey) {\n        if (!globalEffectStyleKeys.has(effectKey)) {\n          globalEffectStyleKeys.add(effectKey);\n          // Inject\n          updateCSS(normalizeStyle(effectStyle[effectKey]), \"_effect-\".concat(effectKey), {\n            mark: ATTR_MARK,\n            prepend: 'queue',\n            attachTo: container\n          });\n        }\n      });\n    }\n    return [styleStr, tokenKey.value, styleId];\n  },\n  // Remove cache if no need\n  function (_ref, fromHMR) {\n    var _ref3 = _slicedToArray(_ref, 3),\n      styleId = _ref3[2];\n    if ((fromHMR || styleContext.value.autoClear) && isClientSide) {\n      removeCSS(styleId, {\n        mark: ATTR_MARK\n      });\n    }\n  });\n  return function (node) {\n    return node;\n    // let styleNode: VueNode;\n    // if (!styleContext.ssrInline || isMergedClientSide || !styleContext.defaultCache) {\n    //   styleNode = <Empty />;\n    // } else {\n    //   styleNode = (\n    //     <style\n    //       {...{\n    //         [ATTR_TOKEN]: cacheStyle.value[1],\n    //         [ATTR_MARK]: cacheStyle.value[2],\n    //       }}\n    //       innerHTML={cacheStyle.value[0]}\n    //     />\n    //   );\n    // }\n    // return (\n    //   <>\n    //     {styleNode}\n    //     {node}\n    //   </>\n    // );\n  };\n}\n// ============================================================================\n// ==                                  SSR                                   ==\n// ============================================================================\nexport function extractStyle(cache) {\n  // prefix with `style` is used for `useStyleRegister` to cache style context\n  var styleKeys = Array.from(cache.cache.keys()).filter(function (key) {\n    return key.startsWith('style%');\n  });\n  // const tokenStyles: Record<string, string[]> = {};\n  var styleText = '';\n  styleKeys.forEach(function (key) {\n    var _cache$cache$get$ = _slicedToArray(cache.cache.get(key)[1], 3),\n      styleStr = _cache$cache$get$[0],\n      tokenKey = _cache$cache$get$[1],\n      styleId = _cache$cache$get$[2];\n    styleText += \"<style \".concat(ATTR_TOKEN, \"=\\\"\").concat(tokenKey, \"\\\" \").concat(ATTR_MARK, \"=\\\"\").concat(styleId, \"\\\">\").concat(styleStr, \"</style>\");\n  });\n  return styleText;\n}","map":{"version":3,"names":["_extends","hash","unitless","compile","serialize","stringify","contentQuotesLinter","hashedAnimationLinter","useStyleInject","ATTR_DEV_CACHE_PATH","ATTR_MARK","ATTR_TOKEN","CSS_IN_JS_INSTANCE","CSS_IN_JS_INSTANCE_ID","supportLayer","useGlobalCache","canUseDom","removeCSS","updateCSS","computed","isClientSide","SKIP_CHECK","normalizeStyle","styleStr","serialized","replace","isCompoundCSSProperty","value","_typeof","injectSelectorHash","key","hashId","hashPriority","hashClassName","concat","hashSelector","keys","split","map","k","_a","fullPath","trim","firstPath","htmlElement","match","slice","length","_toConsumableArray","join","globalEffectStyleKeys","Set","_cf","process","env","NODE_ENV","clear","undefined","parseStyle","interpolation","config","arguments","_ref2","root","parentSelectors","injectHash","layer","path","_config$transformers","transformers","_config$linters","linters","effectStyle","parseKeyframes","keyframes","animationName","getName","_parseStyle","style","_parseStyle2","_slicedToArray","parsedStr","flattenList","list","fullList","forEach","item","Array","isArray","push","flattenStyleList","originStyle","_keyframe","mergedStyle","reduce","prev","trans","visit","call","Object","subInjectHash","mergedKey","nextRoot","startsWith","_parseStyle3","_parseStyle4","childEffectStyle","actualValue","linter","styleName","toLowerCase","formatValue","layerCells","layerName","uniqueHash","useStyleRegister","info","styleFn","styleContext","tokenKey","token","_tokenKey","isMergedClientSide","mock","styleObj","_styleContext$value","container","_info$value","_parseStyle5","_parseStyle6","parsedStyle","styleId","mark","prepend","attachTo","setAttribute","effectKey","has","add","_ref","fromHMR","_ref3","autoClear","node","extractStyle","cache","styleKeys","from","filter","styleText","_cache$cache$get$","get"],"sources":["C:/Users/zhouy/WebstormProjects/lingo/node_modules/ant-design-vue/es/_util/cssinjs/hooks/useStyleRegister.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport hash from '@emotion/hash';\n// @ts-ignore\nimport unitless from '@emotion/unitless';\nimport { compile, serialize, stringify } from 'stylis';\nimport { contentQuotesLinter, hashedAnimationLinter } from '../linters';\nimport { useStyleInject, ATTR_DEV_CACHE_PATH, ATTR_MARK, ATTR_TOKEN, CSS_IN_JS_INSTANCE, CSS_IN_JS_INSTANCE_ID } from '../StyleContext';\nimport { supportLayer } from '../util';\nimport useGlobalCache from './useGlobalCache';\nimport canUseDom from '../../canUseDom';\nimport { removeCSS, updateCSS } from '../../../vc-util/Dom/dynamicCSS';\nimport { computed } from 'vue';\nconst isClientSide = canUseDom();\nconst SKIP_CHECK = '_skip_check_';\n// ============================================================================\n// ==                                 Parser                                 ==\n// ============================================================================\n// Preprocessor style content to browser support one\nexport function normalizeStyle(styleStr) {\n  const serialized = serialize(compile(styleStr), stringify);\n  return serialized.replace(/\\{%%%\\:[^;];}/g, ';');\n}\nfunction isCompoundCSSProperty(value) {\n  return typeof value === 'object' && value && SKIP_CHECK in value;\n}\n// 注入 hash 值\nfunction injectSelectorHash(key, hashId, hashPriority) {\n  if (!hashId) {\n    return key;\n  }\n  const hashClassName = `.${hashId}`;\n  const hashSelector = hashPriority === 'low' ? `:where(${hashClassName})` : hashClassName;\n  // 注入 hashId\n  const keys = key.split(',').map(k => {\n    var _a;\n    const fullPath = k.trim().split(/\\s+/);\n    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。\n    let firstPath = fullPath[0] || '';\n    const htmlElement = ((_a = firstPath.match(/^\\w+/)) === null || _a === void 0 ? void 0 : _a[0]) || '';\n    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;\n    return [firstPath, ...fullPath.slice(1)].join(' ');\n  });\n  return keys.join(',');\n}\n// Global effect style will mount once and not removed\n// The effect will not save in SSR cache (e.g. keyframes)\nconst globalEffectStyleKeys = new Set();\n/**\n * @private Test only. Clear the global effect style keys.\n */\nexport const _cf = process.env.NODE_ENV !== 'production' ? () => globalEffectStyleKeys.clear() : undefined;\n// Parse CSSObject to style content\nexport const parseStyle = function (interpolation) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    root,\n    injectHash,\n    parentSelectors\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    root: true,\n    parentSelectors: []\n  };\n  const {\n    hashId,\n    layer,\n    path,\n    hashPriority,\n    transformers = [],\n    linters = []\n  } = config;\n  let styleStr = '';\n  let effectStyle = {};\n  function parseKeyframes(keyframes) {\n    const animationName = keyframes.getName(hashId);\n    if (!effectStyle[animationName]) {\n      const [parsedStr] = parseStyle(keyframes.style, config, {\n        root: false,\n        parentSelectors\n      });\n      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;\n    }\n  }\n  function flattenList(list) {\n    let fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    list.forEach(item => {\n      if (Array.isArray(item)) {\n        flattenList(item, fullList);\n      } else if (item) {\n        fullList.push(item);\n      }\n    });\n    return fullList;\n  }\n  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);\n  flattenStyleList.forEach(originStyle => {\n    // Only root level can use raw string\n    const style = typeof originStyle === 'string' && !root ? {} : originStyle;\n    if (typeof style === 'string') {\n      styleStr += `${style}\\n`;\n    } else if (style._keyframe) {\n      // Keyframe\n      parseKeyframes(style);\n    } else {\n      const mergedStyle = transformers.reduce((prev, trans) => {\n        var _a;\n        return ((_a = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a === void 0 ? void 0 : _a.call(trans, prev)) || prev;\n      }, style);\n      // Normal CSSObject\n      Object.keys(mergedStyle).forEach(key => {\n        var _a;\n        const value = mergedStyle[key];\n        if (typeof value === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {\n          let subInjectHash = false;\n          // 当成嵌套对象来处理\n          let mergedKey = key.trim();\n          // Whether treat child as root. In most case it is false.\n          let nextRoot = false;\n          // 拆分多个选择器\n          if ((root || injectHash) && hashId) {\n            if (mergedKey.startsWith('@')) {\n              // 略过媒体查询，交给子节点继续插入 hashId\n              subInjectHash = true;\n            } else {\n              // 注入 hashId\n              mergedKey = injectSelectorHash(key, hashId, hashPriority);\n            }\n          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {\n            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,\n            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.\n            // But it does not conform to stylis syntax,\n            // and finally we will get `{color:red;}` as css, which is wrong.\n            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.\n            mergedKey = '';\n            nextRoot = true;\n          }\n          const [parsedStr, childEffectStyle] = parseStyle(value, config, {\n            root: nextRoot,\n            injectHash: subInjectHash,\n            parentSelectors: [...parentSelectors, mergedKey]\n          });\n          effectStyle = _extends(_extends({}, effectStyle), childEffectStyle);\n          styleStr += `${mergedKey}${parsedStr}`;\n        } else {\n          const actualValue = (_a = value === null || value === void 0 ? void 0 : value.value) !== null && _a !== void 0 ? _a : value;\n          if (process.env.NODE_ENV !== 'production' && (typeof value !== 'object' || !(value === null || value === void 0 ? void 0 : value[SKIP_CHECK]))) {\n            [contentQuotesLinter, hashedAnimationLinter, ...linters].forEach(linter => linter(key, actualValue, {\n              path,\n              hashId,\n              parentSelectors\n            }));\n          }\n          // 如果是样式则直接插入\n          const styleName = key.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n          // Auto suffix with px\n          let formatValue = actualValue;\n          if (!unitless[key] && typeof formatValue === 'number' && formatValue !== 0) {\n            formatValue = `${formatValue}px`;\n          }\n          // handle animationName & Keyframe value\n          if (key === 'animationName' && (value === null || value === void 0 ? void 0 : value._keyframe)) {\n            parseKeyframes(value);\n            formatValue = value.getName(hashId);\n          }\n          styleStr += `${styleName}:${formatValue};`;\n        }\n      });\n    }\n  });\n  if (!root) {\n    styleStr = `{${styleStr}}`;\n  } else if (layer && supportLayer()) {\n    const layerCells = layer.split(',');\n    const layerName = layerCells[layerCells.length - 1].trim();\n    styleStr = `@layer ${layerName} {${styleStr}}`;\n    // Order of layer if needed\n    if (layerCells.length > 1) {\n      // zombieJ: stylis do not support layer order, so we need to handle it manually.\n      styleStr = `@layer ${layer}{%%%:%}${styleStr}`;\n    }\n  }\n  return [styleStr, effectStyle];\n};\n// ============================================================================\n// ==                                Register                                ==\n// ============================================================================\nfunction uniqueHash(path, styleStr) {\n  return hash(`${path.join('%')}${styleStr}`);\n}\n// function Empty() {\n//   return null;\n// }\n/**\n * Register a style to the global style sheet.\n */\nexport default function useStyleRegister(info, styleFn) {\n  const styleContext = useStyleInject();\n  const tokenKey = computed(() => info.value.token._tokenKey);\n  const fullPath = computed(() => [tokenKey.value, ...info.value.path]);\n  // Check if need insert style\n  let isMergedClientSide = isClientSide;\n  if (process.env.NODE_ENV !== 'production' && styleContext.value.mock !== undefined) {\n    isMergedClientSide = styleContext.value.mock === 'client';\n  }\n  // const [cacheStyle[0], cacheStyle[1], cacheStyle[2]]\n  useGlobalCache('style', fullPath,\n  // Create cache if needed\n  () => {\n    const styleObj = styleFn();\n    const {\n      hashPriority,\n      container,\n      transformers,\n      linters\n    } = styleContext.value;\n    const {\n      path,\n      hashId,\n      layer\n    } = info.value;\n    const [parsedStyle, effectStyle] = parseStyle(styleObj, {\n      hashId,\n      hashPriority,\n      layer,\n      path: path.join('-'),\n      transformers,\n      linters\n    });\n    const styleStr = normalizeStyle(parsedStyle);\n    const styleId = uniqueHash(fullPath.value, styleStr);\n    if (isMergedClientSide) {\n      const style = updateCSS(styleStr, styleId, {\n        mark: ATTR_MARK,\n        prepend: 'queue',\n        attachTo: container\n      });\n      style[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;\n      // Used for `useCacheToken` to remove on batch when token removed\n      style.setAttribute(ATTR_TOKEN, tokenKey.value);\n      // Dev usage to find which cache path made this easily\n      if (process.env.NODE_ENV !== 'production') {\n        style.setAttribute(ATTR_DEV_CACHE_PATH, fullPath.value.join('|'));\n      }\n      // Inject client side effect style\n      Object.keys(effectStyle).forEach(effectKey => {\n        if (!globalEffectStyleKeys.has(effectKey)) {\n          globalEffectStyleKeys.add(effectKey);\n          // Inject\n          updateCSS(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {\n            mark: ATTR_MARK,\n            prepend: 'queue',\n            attachTo: container\n          });\n        }\n      });\n    }\n    return [styleStr, tokenKey.value, styleId];\n  },\n  // Remove cache if no need\n  (_ref, fromHMR) => {\n    let [,, styleId] = _ref;\n    if ((fromHMR || styleContext.value.autoClear) && isClientSide) {\n      removeCSS(styleId, {\n        mark: ATTR_MARK\n      });\n    }\n  });\n  return node => {\n    return node;\n    // let styleNode: VueNode;\n    // if (!styleContext.ssrInline || isMergedClientSide || !styleContext.defaultCache) {\n    //   styleNode = <Empty />;\n    // } else {\n    //   styleNode = (\n    //     <style\n    //       {...{\n    //         [ATTR_TOKEN]: cacheStyle.value[1],\n    //         [ATTR_MARK]: cacheStyle.value[2],\n    //       }}\n    //       innerHTML={cacheStyle.value[0]}\n    //     />\n    //   );\n    // }\n    // return (\n    //   <>\n    //     {styleNode}\n    //     {node}\n    //   </>\n    // );\n  };\n}\n// ============================================================================\n// ==                                  SSR                                   ==\n// ============================================================================\nexport function extractStyle(cache) {\n  // prefix with `style` is used for `useStyleRegister` to cache style context\n  const styleKeys = Array.from(cache.cache.keys()).filter(key => key.startsWith('style%'));\n  // const tokenStyles: Record<string, string[]> = {};\n  let styleText = '';\n  styleKeys.forEach(key => {\n    const [styleStr, tokenKey, styleId] = cache.cache.get(key)[1];\n    styleText += `<style ${ATTR_TOKEN}=\"${tokenKey}\" ${ATTR_MARK}=\"${styleId}\">${styleStr}</style>`;\n  });\n  return styleText;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}